
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Parsing Inputs &#8212; The Fuzzing Book</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css?v=42e1b1a5" />
    <link rel="stylesheet" type="text/css" href="_static/mastodon-timeline.css?v=f82c2b23" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=f281be69"></script>
    <script src="_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'Parser';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Probabilistic Grammar Fuzzing" href="ProbabilisticGrammarFuzzer.html" />
    <link rel="prev" title="Grammar Coverage" href="GrammarCoverageFuzzer.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>
<aside class="bd-header-announcement" aria-label="Announcement">
  <div class="bd-header-announcement__content"><p>This is a beta version of fuzzingbook.org, currently in development. See the <a href="https://fuzzingbook.org/"  style="color:white!important;">classic site</a> for resources.</p></div>
</aside>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="_static/fuzzingbook.png" class="logo__image only-light" alt="The Fuzzing Book - Home"/>
    <script>document.write(`<img src="_static/fuzzingbook.png" class="logo__image only-dark" alt="The Fuzzing Book - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="index.html">
                    The Fuzzing Book
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="Tours.html">Tours through the Book</a></li>
<li class="toctree-l1"><a class="reference internal" href="Intro_Testing.html">Introduction to Software Testing</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Lexical Fuzzing</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="Fuzzer.html">Fuzzing: Breaking Things with Random Inputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="Coverage.html">Code Coverage</a></li>
<li class="toctree-l1"><a class="reference internal" href="MutationFuzzer.html">Mutation-Based Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="GreyboxFuzzer.html">Greybox Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="SearchBasedFuzzer.html">Search-Based Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="MutationAnalysis.html">Mutation Analysis</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Syntactical Fuzzing</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="Grammars.html">Fuzzing with Grammars</a></li>
<li class="toctree-l1"><a class="reference internal" href="GrammarFuzzer.html">Efficient Grammar Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="GrammarCoverageFuzzer.html">Grammar Coverage</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Parsing Inputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="ProbabilisticGrammarFuzzer.html">Probabilistic Grammar Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="GeneratorGrammarFuzzer.html">Fuzzing with Generators</a></li>

<li class="toctree-l1"><a class="reference internal" href="GreyboxGrammarFuzzer.html">Greybox Fuzzing with Grammars</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reducer.html">Reducing Failure-Inducing Inputs</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Semantical Fuzzing</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="FuzzingWithConstraints.html">Fuzzing with Constraints</a></li>
<li class="toctree-l1"><a class="reference internal" href="GrammarMiner.html">Mining Input Grammars</a></li>
<li class="toctree-l1"><a class="reference internal" href="InformationFlow.html">Tracking Information Flow</a></li>
<li class="toctree-l1"><a class="reference internal" href="ConcolicFuzzer.html">Concolic Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="SymbolicFuzzer.html">Symbolic Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="DynamicInvariants.html">Mining Function Specifications</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Domain-Specific Fuzzing</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="ConfigurationFuzzer.html">Testing Configurations</a></li>
<li class="toctree-l1"><a class="reference internal" href="APIFuzzer.html">Fuzzing APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="Carver.html">Carving Unit Tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="PythonFuzzer.html">Testing Compilers</a></li>
<li class="toctree-l1"><a class="reference internal" href="WebFuzzer.html">Testing Web Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="GUIFuzzer.html">Testing Graphical User Interfaces</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Managing Fuzzing</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="FuzzingInTheLarge.html">Fuzzing in the Large</a></li>
<li class="toctree-l1"><a class="reference internal" href="WhenToStopFuzzing.html">When To Stop Fuzzing</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendices</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="AcademicPrototyping.html">Academic Prototyping</a></li>
<li class="toctree-l1"><a class="reference internal" href="PrototypingWithPython.html">Prototyping with Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="ExpectError.html">Error Handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="Timer.html">Timer</a></li>
<li class="toctree-l1"><a class="reference internal" href="Timeout.html">Timeout</a></li>
<li class="toctree-l1"><a class="reference internal" href="ClassDiagram.html">Class Diagrams</a></li>
<li class="toctree-l1"><a class="reference internal" href="RailroadDiagrams.html">Railroad Diagrams</a></li>
<li class="toctree-l1"><a class="reference internal" href="ControlFlow.html">Control Flow Graph</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">About This Book</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="ReleaseNotes.html">Fuzzingbook Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="Importing.html">Using Fuzzingbook Code in your own Programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="Guide_for_Authors.html">Guide for Authors</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://mybinder.org/v2/gh/uds-se/fuzzingbook/master?urlpath=tree/docs/notebooks/Parser.ipynb" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch on Binder"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img alt="Binder logo" src="_static/images/logo_binder.svg">
  </span>
<span class="btn__text-container">Binder</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/uds-se/fuzzingbook" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/uds-se/fuzzingbook/issues/new?title=Issue%20on%20page%20%2FParser.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/Parser.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Parsing Inputs</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#synopsis">Synopsis</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#why-parsing-for-fuzzing">Why Parsing for Fuzzing?</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#using-a-parser">Using a Parser</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#an-ad-hoc-parser">An Ad Hoc Parser</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#grammars-in-parsing">Grammars in Parsing</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-grammars-and-derivation-trees">Excursion: Grammars and Derivation Trees</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#end-of-excursion">End of Excursion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-recursion">Excursion: Recursion</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#recursion">Recursion</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#ambiguity">Ambiguity</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">End of Excursion</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-parser-class">A Parser Class</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-canonical-grammars">Excursion: Canonical Grammars</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">End of Excursion</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#parsing-expression-grammars">Parsing Expression Grammars</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-packrat-parser-for-predicate-expression-grammars">The Packrat Parser for Predicate Expression Grammars</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-implementing-pegparser">Excursion: Implementing <code class="docutils literal notranslate"><span class="pre">PEGParser</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#unify-key">Unify Key</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#unify-rule">Unify Rule</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">End of Excursion</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#parsing-context-free-grammars">Parsing Context-Free Grammars</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problems-with-peg">Problems with PEG</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-earley-parser">The Earley Parser</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-implementing-earleyparser">Excursion: Implementing <code class="docutils literal notranslate"><span class="pre">EarleyParser</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#columns">Columns</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#items">Items</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#states">States</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#the-parsing-algorithm">The Parsing Algorithm</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#predicting-states">Predicting States</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#scanning-tokens">Scanning Tokens</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#completing-processing">Completing Processing</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#filling-the-chart">Filling the Chart</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#the-parse-method">The Parse Method</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#parsing-paths">Parsing Paths</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#parsing-forests">Parsing Forests</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#extracting-trees">Extracting Trees</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#ambiguous-parsing">Ambiguous Parsing</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#the-aycock-epsilon-fix">The Aycock Epsilon Fix</a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#fixpoint">Fixpoint</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#nullable">Nullable</a></li>
</ul>
</li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#tree-extractor">Tree Extractor</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#more-earley-parsing">More Earley Parsing</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">End of Excursion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-testing-the-parsers">Excursion: Testing the Parsers</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">End of Excursion</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#background">Background</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">Synopsis</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#lessons-learned">Lessons Learned</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#next-steps">Next Steps</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">Exercises</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-1-an-alternative-packrat">Exercise 1: An Alternative Packrat</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-2-more-peg-syntax">Exercise 2: More PEG Syntax</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-3-peg-predicates">Exercise 3: PEG Predicates</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-4-earley-fill-chart">Exercise 4: Earley Fill Chart</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-5-leo-parser">Exercise 5: Leo Parser</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-6-filtered-earley-parser">Exercise 6: Filtered Earley Parser</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-7-iterative-earley-parser">Exercise 7: Iterative Earley Parser</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-8-first-set-of-a-nonterminal">Exercise 8: First Set of a Nonterminal</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-9-follow-set-of-a-nonterminal">Exercise 9: Follow Set of a Nonterminal</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-10-a-ll-1-parser">Exercise 10: A LL(1) Parser</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#part-1-a-ll-1-parsing-table">Part 1: A LL(1) Parsing Table</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#part-2-the-parser">Part 2: The Parser</a></li>
</ul>
</li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="parsing-inputs">
<h1>Parsing Inputs<a class="headerlink" href="#parsing-inputs" title="Link to this heading">#</a></h1>
<p>In the chapter on <a class="reference internal" href="Grammars.html"><span class="std std-doc">Grammars</span></a>, we discussed how grammars can be
used to represent various languages. We also saw how grammars can be used to
generate strings of the corresponding language. Grammars can also perform the
reverse. That is, given a string, one can decompose the string into its
constituent parts that correspond to the parts of grammar used to generate it
– the <em>derivation tree</em> of that string. These parts (and parts from other similar
strings) can later be recombined using the same grammar to produce new strings.</p>
<p>In this chapter, we use grammars to parse and decompose a given set of valid seed inputs into their corresponding derivation trees. This structural representation allows us to mutate, crossover, and recombine their parts in order to generate new valid, slightly changed inputs (i.e., fuzz)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bookutils</span> <span class="kn">import</span> <span class="n">YouTubeVideo</span>
<span class="n">YouTubeVideo</span><span class="p">(</span><span class="s1">&#39;k39i9de0L54&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
        <iframe
            width="640"
            height="360"
            src="https://www.youtube-nocookie.com/embed/k39i9de0L54"
            frameborder="0"
            allowfullscreen
            
        ></iframe>
        </div></div>
</div>
<p><strong>Prerequisites</strong></p>
<ul class="simple">
<li><p>You should have read the <a class="reference internal" href="Grammars.html"><span class="std std-doc">chapter on grammars</span></a>.</p></li>
<li><p>An understanding of derivation trees from the <a class="reference internal" href="GrammarFuzzer.html"><span class="std std-doc">chapter on grammar fuzzer</span></a>
is also required.</p></li>
</ul>
<section id="synopsis">
<h2>Synopsis<a class="headerlink" href="#synopsis" title="Link to this heading">#</a></h2>
<!-- Automatically generated. Do not edit. -->
<p>To <a class="reference internal" href="Importing.html"><span class="std std-doc">use the code provided in this chapter</span></a>, write</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fuzzingbook.Parser</span> <span class="kn">import</span> <span class="o">&lt;</span><span class="n">identifier</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>and then make use of the following features.</p>
<p>This chapter introduces <code class="docutils literal notranslate"><span class="pre">Parser</span></code> classes, parsing a string into a <em>derivation tree</em> as introduced in the <a class="reference internal" href="GrammarFuzzer.html"><span class="std std-doc">chapter on efficient grammar fuzzing</span></a>.  Two important parser classes are provided:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Parsing-Expression-Grammars"><span class="xref myst">Parsing Expression Grammar parsers</span></a> (<code class="docutils literal notranslate"><span class="pre">PEGParser</span></code>). These are very efficient, but limited to specific grammar structure. Notably, the alternatives represent <em>ordered choice</em>. That is, rather than choosing all rules that can potentially match, we stop at the first match that succeed.</p></li>
<li><p><a class="reference internal" href="#Parsing-Context-Free-Grammars"><span class="xref myst">Earley parsers</span></a> (<code class="docutils literal notranslate"><span class="pre">EarleyParser</span></code>). These accept any kind of context-free grammars, and explore all parsing alternatives (if any).</p></li>
</ul>
<p>Using any of these is fairly easy, though.  First, instantiate them with a grammar:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Grammars</span> <span class="kn">import</span> <span class="n">US_PHONE_GRAMMAR</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">us_phone_parser</span> <span class="o">=</span> <span class="n">EarleyParser</span><span class="p">(</span><span class="n">US_PHONE_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
<p>Then, use the <code class="docutils literal notranslate"><span class="pre">parse()</span></code> method to retrieve a list of possible derivation trees:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">trees</span> <span class="o">=</span> <span class="n">us_phone_parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;(555)987-6543&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">trees</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
<p><img alt="" src="_images/Parser-synopsis-1.svg" /></p>
<p>These derivation trees can then be used for test generation, notably for mutating and recombining existing inputs.</p>
<p><img alt="" src="_images/Parser-synopsis-2.svg" /></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">bookutils.setup</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Collection</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Generator</span><span class="p">,</span> <span class="n">cast</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Fuzzer</span> <span class="kn">import</span> <span class="n">Fuzzer</span>  <span class="c1"># minor dependency</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Grammars</span> <span class="kn">import</span> <span class="n">EXPR_GRAMMAR</span><span class="p">,</span> <span class="n">START_SYMBOL</span><span class="p">,</span> <span class="n">RE_NONTERMINAL</span>
<span class="kn">from</span> <span class="nn">Grammars</span> <span class="kn">import</span> <span class="n">is_valid_grammar</span><span class="p">,</span> <span class="n">syntax_diagram</span><span class="p">,</span> <span class="n">Grammar</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">GrammarFuzzer</span> <span class="kn">import</span> <span class="n">GrammarFuzzer</span><span class="p">,</span> <span class="n">display_tree</span><span class="p">,</span> <span class="n">tree_to_string</span><span class="p">,</span> <span class="n">dot_escape</span>
<span class="kn">from</span> <span class="nn">GrammarFuzzer</span> <span class="kn">import</span> <span class="n">DerivationTree</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ExpectError</span> <span class="kn">import</span> <span class="n">ExpectError</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">display</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Timer</span> <span class="kn">import</span> <span class="n">Timer</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="why-parsing-for-fuzzing">
<h2>Why Parsing for Fuzzing?<a class="headerlink" href="#why-parsing-for-fuzzing" title="Link to this heading">#</a></h2>
<p>Why would one want to parse existing inputs in order to fuzz? Let us illustrate the problem with an example. Here is a simple program that accepts a CSV file of vehicle details and processes this information.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">process_inventory</span><span class="p">(</span><span class="n">inventory</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">vehicle</span> <span class="ow">in</span> <span class="n">inventory</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">process_vehicle</span><span class="p">(</span><span class="n">vehicle</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The CSV file contains details of one vehicle per line. Each row is processed in <code class="docutils literal notranslate"><span class="pre">process_vehicle()</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">process_vehicle</span><span class="p">(</span><span class="n">vehicle</span><span class="p">):</span>
    <span class="n">year</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">company</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">vehicle</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;van&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">process_van</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">company</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;car&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">process_car</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">company</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Invalid entry&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Depending on the kind of vehicle, the processing changes.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">process_van</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">company</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;We have a </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> van from </span><span class="si">%s</span><span class="s2"> vintage.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">company</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">year</span><span class="p">)]</span>
    <span class="n">iyear</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">year</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iyear</span> <span class="o">&gt;</span> <span class="mi">2010</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;It is a recent model!&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;It is an old but reliable model!&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">process_car</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">company</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;We have a </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> car from </span><span class="si">%s</span><span class="s2"> vintage.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">company</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">year</span><span class="p">)]</span>
    <span class="n">iyear</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">year</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iyear</span> <span class="o">&gt;</span> <span class="mi">2016</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;It is a recent model!&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;It is an old but reliable model!&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span>
</pre></div>
</div>
</div>
</div>
<p>Here is a sample of inputs that the <code class="docutils literal notranslate"><span class="pre">process_inventory()</span></code> accepts.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">1997,van,Ford,E350</span>
<span class="s2">2000,car,Mercury,Cougar</span><span class="se">\</span>
<span class="s2">&quot;&quot;&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">process_inventory</span><span class="p">(</span><span class="n">mystring</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>We have a Ford E350 van from 1997 vintage.
It is an old but reliable model!
We have a Mercury Cougar car from 2000 vintage.
It is an old but reliable model!
</pre></div>
</div>
</div>
</div>
<p>Let us try to fuzz this program. Given that the <code class="docutils literal notranslate"><span class="pre">process_inventory()</span></code> takes a CSV file, we can write a simple grammar for generating comma separated values, and generate the required CSV rows. For convenience, we fuzz <code class="docutils literal notranslate"><span class="pre">process_vehicle()</span></code> directly.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">string</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">CSV_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;csvline&gt;&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;csvline&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;items&gt;&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;items&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;item&gt;,&lt;items&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;item&gt;&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;item&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;letters&gt;&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;letters&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;letter&gt;&lt;letters&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;letter&gt;&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;letter&gt;&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">ascii_letters</span> <span class="o">+</span> <span class="n">string</span><span class="o">.</span><span class="n">digits</span> <span class="o">+</span> <span class="n">string</span><span class="o">.</span><span class="n">punctuation</span> <span class="o">+</span> <span class="s1">&#39; </span><span class="se">\t\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>We need some infrastructure first for viewing the grammar.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">syntax_diagram</span><span class="p">(</span><span class="n">CSV_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>start
</pre></div>
</div>
<img alt="_images/4e033552302e4996d35096ac07dca77f4aa3509a8a415e3356c1e3833055f631.svg" src="_images/4e033552302e4996d35096ac07dca77f4aa3509a8a415e3356c1e3833055f631.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>csvline
</pre></div>
</div>
<img alt="_images/314a6f10351f2f3d2787b6bda3fee0fb30ca70fd4922cc379cfad8d78d159c21.svg" src="_images/314a6f10351f2f3d2787b6bda3fee0fb30ca70fd4922cc379cfad8d78d159c21.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>items
</pre></div>
</div>
<img alt="_images/81cdba0d23b0c1e246ec0a7f0a6a61db5f082e6ec4839ab5e600696c6529991e.svg" src="_images/81cdba0d23b0c1e246ec0a7f0a6a61db5f082e6ec4839ab5e600696c6529991e.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>item
</pre></div>
</div>
<img alt="_images/dc18fe6c1b0dcb5189bebdff34d956f40d50ebf4de037d98398278592ee2c857.svg" src="_images/dc18fe6c1b0dcb5189bebdff34d956f40d50ebf4de037d98398278592ee2c857.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>letters
</pre></div>
</div>
<img alt="_images/ef533271a58cba2773a70664eaf54fb7646940d0deb62915fa01019ab4ad72dd.svg" src="_images/ef533271a58cba2773a70664eaf54fb7646940d0deb62915fa01019ab4ad72dd.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>letter
</pre></div>
</div>
<img alt="_images/44d51b88eba5679981161dcd257aa4d520157dc0bcfeec6464f44a7f37aaeed7.svg" src="_images/44d51b88eba5679981161dcd257aa4d520157dc0bcfeec6464f44a7f37aaeed7.svg" />
</div>
</div>
<p>We generate <code class="docutils literal notranslate"><span class="pre">1000</span></code> values, and evaluate the <code class="docutils literal notranslate"><span class="pre">process_vehicle()</span></code> with each.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gf</span> <span class="o">=</span> <span class="n">GrammarFuzzer</span><span class="p">(</span><span class="n">CSV_GRAMMAR</span><span class="p">,</span> <span class="n">min_nonterminals</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">trials</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">valid</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">time</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">trials</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">Timer</span><span class="p">()</span> <span class="k">as</span> <span class="n">t</span><span class="p">:</span>
        <span class="n">vehicle_info</span> <span class="o">=</span> <span class="n">gf</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">process_vehicle</span><span class="p">(</span><span class="n">vehicle_info</span><span class="p">)</span>
            <span class="n">valid</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vehicle_info</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">time</span> <span class="o">+=</span> <span class="n">t</span><span class="o">.</span><span class="n">elapsed_time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> valid strings, that is GrammarFuzzer generated </span><span class="si">%f%%</span><span class="s2"> valid entries from </span><span class="si">%d</span><span class="s2"> inputs&quot;</span> <span class="o">%</span>
      <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">valid</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid</span><span class="p">)</span> <span class="o">*</span> <span class="mf">100.0</span> <span class="o">/</span> <span class="n">trials</span><span class="p">,</span> <span class="n">trials</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total time of </span><span class="si">%f</span><span class="s2"> seconds&quot;</span> <span class="o">%</span> <span class="n">time</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0 valid strings, that is GrammarFuzzer generated 0.000000% valid entries from 1000 inputs
Total time of 2.478398 seconds
</pre></div>
</div>
</div>
</div>
<p>This is obviously not working. But why?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gf</span> <span class="o">=</span> <span class="n">GrammarFuzzer</span><span class="p">(</span><span class="n">CSV_GRAMMAR</span><span class="p">,</span> <span class="n">min_nonterminals</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">trials</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">time</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">trials</span><span class="p">):</span>
    <span class="n">vehicle_info</span> <span class="o">=</span> <span class="n">gf</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">vehicle_info</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">process_vehicle</span><span class="p">(</span><span class="n">vehicle_info</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;9w9J\&#39;/,LU&lt;&quot;l,|,Y,Zv)Amvx,c\n&#39;	 Invalid entry
&#39;(n8].H7,qolS&#39;	 not enough values to unpack (expected at least 4, got 2)
&#39;\nQoLWQ,jSa&#39;	 not enough values to unpack (expected at least 4, got 2)
&#39;K1,\n,RE,fq,%,,sT+aAb&#39;	 Invalid entry
&quot;m,d,,8j4&#39;),-yQ,B7&quot;	 Invalid entry
&#39;g4,s1\t[}{.,M,&lt;,\nzd,.am&#39;	 Invalid entry
&#39;,Z[,z,c,#x1,gc.F&#39;	 Invalid entry
&#39;pWs,rT`,R&#39;	 not enough values to unpack (expected at least 4, got 3)
&#39;iN,br%,Q,R&#39;	 Invalid entry
&#39;ol,\nH&lt;\tn,^#,=A&#39;	 Invalid entry
</pre></div>
</div>
</div>
</div>
<p>None of the entries will get through unless the fuzzer can produce either <code class="docutils literal notranslate"><span class="pre">van</span></code> or <code class="docutils literal notranslate"><span class="pre">car</span></code>.
Indeed, the reason is that the grammar itself does not capture the complete information about the format. So here is another idea. We modify the <code class="docutils literal notranslate"><span class="pre">GrammarFuzzer</span></code> to know a bit about our format.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">copy</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PooledGrammarFuzzer</span><span class="p">(</span><span class="n">GrammarFuzzer</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_cache</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">update_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>

    <span class="k">def</span> <span class="nf">expand_node_randomly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span> <span class="o">=</span> <span class="n">node</span>
        <span class="k">assert</span> <span class="n">children</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_cache</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">expand_node_randomly</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_cache</span><span class="p">[</span><span class="n">symbol</span><span class="p">]))</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">expand_node_randomly</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let us try again!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gf</span> <span class="o">=</span> <span class="n">PooledGrammarFuzzer</span><span class="p">(</span><span class="n">CSV_GRAMMAR</span><span class="p">,</span> <span class="n">min_nonterminals</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">gf</span><span class="o">.</span><span class="n">update_cache</span><span class="p">(</span><span class="s1">&#39;&lt;item&gt;&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="p">(</span><span class="s1">&#39;&lt;item&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;car&#39;</span><span class="p">,</span> <span class="p">[])]),</span>
    <span class="p">(</span><span class="s1">&#39;&lt;item&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;van&#39;</span><span class="p">,</span> <span class="p">[])]),</span>
<span class="p">])</span>
<span class="n">trials</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">time</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">trials</span><span class="p">):</span>
    <span class="n">vehicle_info</span> <span class="o">=</span> <span class="n">gf</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">vehicle_info</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">process_vehicle</span><span class="p">(</span><span class="n">vehicle_info</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;,h,van,|&#39;	 Invalid entry
&#39;M,w:K,car,car,van&#39;	 Invalid entry
&#39;J,?Y,van,van,car,J,~D+&#39;	 Invalid entry
&#39;S4,car,car,o&#39;	 invalid literal for int() with base 10: &#39;S4&#39;
&#39;2*-,van&#39;	 not enough values to unpack (expected at least 4, got 2)
&#39;van,%,5,]&#39;	 Invalid entry
&#39;van,G3{y,j,h:&#39;	 Invalid entry
&#39;$0;o,M,car,car&#39;	 Invalid entry
&#39;2d,f,e&#39;	 not enough values to unpack (expected at least 4, got 3)
&#39;/~NE,car,car&#39;	 not enough values to unpack (expected at least 4, got 3)
</pre></div>
</div>
</div>
</div>
<p>At least we are getting somewhere! It would be really nice if <em>we could incorporate what we know about the sample data in our fuzzer.</em> In fact, it would be nice if we could <em>extract</em> the template and valid values from samples, and use them in our fuzzing. How do we do that?  The quick answer to this question is: Use a <em>parser</em>.</p>
</section>
<section id="using-a-parser">
<h2>Using a Parser<a class="headerlink" href="#using-a-parser" title="Link to this heading">#</a></h2>
<p>Generally speaking, a <em>parser</em> is the part of a program that processes (structured) input.  The parsers we discuss in this chapter transform an input string into a <em>derivation tree</em> (discussed in the <a class="reference internal" href="GrammarFuzzer.html"><span class="std std-doc">chapter on efficient grammar fuzzing</span></a>).  From a user’s perspective, all it takes to parse an input is two steps:</p>
<ol class="arabic simple">
<li><p>Initialize the parser with a grammar, as in</p></li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">parser</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>Using the parser to retrieve a list of derivation trees:</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">trees</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
</pre></div>
</div>
<p>Once we have parsed a tree, we can use it just as the derivation trees produced from grammar fuzzing.</p>
<p>We discuss a number of such parsers, in particular</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Parsing-Expression-Grammars"><span class="xref myst">parsing expression grammar parsers</span></a> (<code class="docutils literal notranslate"><span class="pre">PEGParser</span></code>), which are very efficient, but limited to specific grammar structure; and</p></li>
<li><p><a class="reference internal" href="#Parsing-Context-Free-Grammars"><span class="xref myst">Earley parsers</span></a> (<code class="docutils literal notranslate"><span class="pre">EarleyParser</span></code>), which accept any kind of context-free grammars.</p></li>
</ul>
<p>If you just want to <em>use</em> parsers (say, because your main focus is testing), you can just stop here and move on <a class="reference internal" href="LangFuzzer.html"><span class="std std-doc">to the next chapter</span></a>, where we learn how to make use of parsed inputs to mutate and recombine them.  If you want to <em>understand</em> how parsers work, though, this chapter is right for you.</p>
</section>
<section id="an-ad-hoc-parser">
<h2>An Ad Hoc Parser<a class="headerlink" href="#an-ad-hoc-parser" title="Link to this heading">#</a></h2>
<p>As we saw in the previous section, programmers often have to extract parts of data that obey certain rules. For example, for <em>CSV</em> files, each element in a row is separated by <em>commas</em>, and multiple raws are used to store the data.</p>
<p>To extract the information, we write an ad hoc parser <code class="docutils literal notranslate"><span class="pre">simple_parse_csv()</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">simple_parse_csv</span><span class="p">(</span><span class="n">mystring</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DerivationTree</span><span class="p">:</span>
    <span class="n">children</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="p">(</span><span class="n">START_SYMBOL</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mystring</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)):</span>
        <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;record </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="p">[(</span><span class="n">cell</span><span class="p">,</span> <span class="p">[])</span>
                                           <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)]))</span>
    <span class="k">return</span> <span class="n">tree</span>
</pre></div>
</div>
</div>
</div>
<p>We also change the default orientation of the graph to <em>left to right</em> rather than <em>top to bottom</em> for easier viewing using <code class="docutils literal notranslate"><span class="pre">lr_graph()</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">lr_graph</span><span class="p">(</span><span class="n">dot</span><span class="p">):</span>
    <span class="n">dot</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="s1">&#39;node&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="s1">&#39;plain&#39;</span><span class="p">)</span>
    <span class="n">dot</span><span class="o">.</span><span class="n">graph_attr</span><span class="p">[</span><span class="s1">&#39;rankdir&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;LR&#39;</span>
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">display_tree()</span></code> shows the structure of our CSV file after parsing.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tree</span> <span class="o">=</span> <span class="n">simple_parse_csv</span><span class="p">(</span><span class="n">mystring</span><span class="p">)</span>
<span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">graph_attr</span><span class="o">=</span><span class="n">lr_graph</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/e1d8c38a4b77c7b19bd8aa5b250a8f883e541d70ce152abee80228e6c86849bf.svg" src="_images/e1d8c38a4b77c7b19bd8aa5b250a8f883e541d70ce152abee80228e6c86849bf.svg" />
</div>
</div>
<p>This is of course simple. What if we encounter slightly more complexity? Again, another example from the Wikipedia.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s1">1997,Ford,E350,&quot;ac, abs, moon&quot;,3000.00</span><span class="se">\</span>
<span class="s1">&#39;&#39;&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">mystring</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1997,Ford,E350,&quot;ac, abs, moon&quot;,3000.00
</pre></div>
</div>
</div>
</div>
<p>We define a new annotation method <code class="docutils literal notranslate"><span class="pre">highlight_node()</span></code> to mark the nodes that are interesting.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">highlight_node</span><span class="p">(</span><span class="n">predicate</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">hl_node</span><span class="p">(</span><span class="n">dot</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">ann</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">dot</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">ann</span><span class="p">):</span>
            <span class="n">dot</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">nid</span><span class="p">),</span> <span class="n">dot_escape</span><span class="p">(</span><span class="n">symbol</span><span class="p">),</span> <span class="n">fontcolor</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dot</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">nid</span><span class="p">),</span> <span class="n">dot_escape</span><span class="p">(</span><span class="n">symbol</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">hl_node</span>
</pre></div>
</div>
</div>
</div>
<p>Using <code class="docutils literal notranslate"><span class="pre">highlight_node()</span></code> we can highlight particular nodes that we were wrongly parsed.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tree</span> <span class="o">=</span> <span class="n">simple_parse_csv</span><span class="p">(</span><span class="n">mystring</span><span class="p">)</span>
<span class="n">bad_nodes</span> <span class="o">=</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">25</span><span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">hl_predicate</span><span class="p">(</span><span class="n">_d</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">_s</span><span class="p">,</span> <span class="n">_a</span><span class="p">):</span> <span class="k">return</span> <span class="n">nid</span> <span class="ow">in</span> <span class="n">bad_nodes</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">highlight_err_node</span> <span class="o">=</span> <span class="n">highlight_node</span><span class="p">(</span><span class="n">hl_predicate</span><span class="p">)</span>
<span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">node_attr</span><span class="o">=</span><span class="n">highlight_err_node</span><span class="p">,</span>
             <span class="n">graph_attr</span><span class="o">=</span><span class="n">lr_graph</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/1bdc3f87ecfed5acfc915dc919fcb320d36f88fba295fa591880ce87ac7e5d66.svg" src="_images/1bdc3f87ecfed5acfc915dc919fcb320d36f88fba295fa591880ce87ac7e5d66.svg" />
</div>
</div>
<p>The marked nodes indicate where our parsing went wrong. We can of course extend our parser to understand quotes. First we define some of the helper functions <code class="docutils literal notranslate"><span class="pre">parse_quote()</span></code>, <code class="docutils literal notranslate"><span class="pre">find_comma()</span></code> and <code class="docutils literal notranslate"><span class="pre">comma_split()</span></code></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">parse_quote</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">v</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find_comma</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="n">slen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">slen</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">parse_quote</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;,&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">comma_split</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="n">slen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">slen</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">find_comma</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">c</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
</div>
<p>We can update our <code class="docutils literal notranslate"><span class="pre">parse_csv()</span></code> procedure to use our advanced quote parser.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">parse_csv</span><span class="p">(</span><span class="n">mystring</span><span class="p">):</span>
    <span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="p">(</span><span class="n">START_SYMBOL</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mystring</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)):</span>
        <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;record </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="p">[(</span><span class="n">cell</span><span class="p">,</span> <span class="p">[])</span>
                                           <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">comma_split</span><span class="p">(</span><span class="n">line</span><span class="p">)]))</span>
    <span class="k">return</span> <span class="n">tree</span>
</pre></div>
</div>
</div>
</div>
<p>Our new <code class="docutils literal notranslate"><span class="pre">parse_csv()</span></code> can now handle quotes correctly.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tree</span> <span class="o">=</span> <span class="n">parse_csv</span><span class="p">(</span><span class="n">mystring</span><span class="p">)</span>
<span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">graph_attr</span><span class="o">=</span><span class="n">lr_graph</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/8ef68a808f140fce73949ebd4a25dcc77cd27e3f7fb28461c78a3c87dd6ffcfc.svg" src="_images/8ef68a808f140fce73949ebd4a25dcc77cd27e3f7fb28461c78a3c87dd6ffcfc.svg" />
</div>
</div>
<p>That of course does not survive long:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s1">1999,Chevy,&quot;Venture </span><span class="se">\\</span><span class="s1">&quot;Extended Edition, Very Large</span><span class="se">\\</span><span class="s1">&quot;&quot;,,5000.00</span><span class="se">\</span>
<span class="s1">&#39;&#39;&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">mystring</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1999,Chevy,&quot;Venture \&quot;Extended Edition, Very Large\&quot;&quot;,,5000.00
</pre></div>
</div>
</div>
</div>
<p>A few embedded quotes are sufficient to confuse our parser again.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tree</span> <span class="o">=</span> <span class="n">parse_csv</span><span class="p">(</span><span class="n">mystring</span><span class="p">)</span>
<span class="n">bad_nodes</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
<span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">node_attr</span><span class="o">=</span><span class="n">highlight_err_node</span><span class="p">,</span> <span class="n">graph_attr</span><span class="o">=</span><span class="n">lr_graph</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/c20f646642f75130cfdc3dd65891ac1ba475bed88500d9d1ee8ddbd8c1e25bcd.svg" src="_images/c20f646642f75130cfdc3dd65891ac1ba475bed88500d9d1ee8ddbd8c1e25bcd.svg" />
</div>
</div>
<p>Here is another record from that CSV file:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s1">1996,Jeep,Grand Cherokee,&quot;MUST SELL!</span>
<span class="s1">air, moon roof, loaded&quot;,4799.00</span>
<span class="s1">&#39;&#39;&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">mystring</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1996,Jeep,Grand Cherokee,&quot;MUST SELL!
air, moon roof, loaded&quot;,4799.00
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tree</span> <span class="o">=</span> <span class="n">parse_csv</span><span class="p">(</span><span class="n">mystring</span><span class="p">)</span>
<span class="n">bad_nodes</span> <span class="o">=</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">}</span>
<span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">node_attr</span><span class="o">=</span><span class="n">highlight_err_node</span><span class="p">,</span> <span class="n">graph_attr</span><span class="o">=</span><span class="n">lr_graph</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/838ae52c4221293a7d570c9eed9725cf27a5f65137fe1e95dbc0e3c9fe46533a.svg" src="_images/838ae52c4221293a7d570c9eed9725cf27a5f65137fe1e95dbc0e3c9fe46533a.svg" />
</div>
</div>
<p>Fixing this would require modifying both inner <code class="docutils literal notranslate"><span class="pre">parse_quote()</span></code> and the outer <code class="docutils literal notranslate"><span class="pre">parse_csv()</span></code> procedures. We note that each of these features actually documented in the CSV <a class="reference external" href="https://tools.ietf.org/html/rfc4180">RFC 4180</a></p>
<p>Indeed, each additional improvement falls apart even with a little extra complexity. The problem becomes severe when one encounters recursive expressions. For example, JSON is a common alternative to CSV files for saving data. Similarly, one may have to parse data from an HTML table instead of a CSV file if one is getting the data from the web.</p>
<p>One might be tempted to fix it with a little more ad hoc parsing, with a bit of <em>regular expressions</em> thrown in. However, that is the <a class="reference external" href="https://stackoverflow.com/a/1732454">path to insanity</a>.</p>
<p>It is here that <em>formal parsers</em> shine. The main idea is that, any given set of strings belong to a language, and these languages can be specified by their grammars (as we saw in the <a class="reference internal" href="Grammars.html"><span class="std std-doc">chapter on grammars</span></a>). The great thing about grammars is that they can be <em>composed</em>. That is, one can introduce finer and finer details into an internal structure without affecting the external structure, and similarly, one can change the external structure without much impact on the internal structure.</p>
</section>
<section id="grammars-in-parsing">
<h2>Grammars in Parsing<a class="headerlink" href="#grammars-in-parsing" title="Link to this heading">#</a></h2>
<p>We briefly describe grammars in the context of parsing.</p>
<section id="excursion-grammars-and-derivation-trees">
<h3>Excursion: Grammars and Derivation Trees<a class="headerlink" href="#excursion-grammars-and-derivation-trees" title="Link to this heading">#</a></h3>
<p>A grammar, as you have read from the <a class="reference internal" href="Grammars.html"><span class="std std-doc">chapter on grammars</span></a> is a set of <em>rules</em> that explain how the start symbol can be expanded. Each rule has a name, also called a <em>nonterminal</em>, and a set of <em>alternative choices</em> in how the nonterminal can be expanded.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A1_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;&lt;start&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;expr&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;expr&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;expr&gt;+&lt;expr&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;expr&gt;-&lt;expr&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;integer&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;integer&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;digit&gt;&lt;integer&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;digit&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;digit&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">,</span> <span class="s2">&quot;4&quot;</span><span class="p">,</span> <span class="s2">&quot;5&quot;</span><span class="p">,</span> <span class="s2">&quot;6&quot;</span><span class="p">,</span> <span class="s2">&quot;7&quot;</span><span class="p">,</span> <span class="s2">&quot;8&quot;</span><span class="p">,</span> <span class="s2">&quot;9&quot;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">syntax_diagram</span><span class="p">(</span><span class="n">A1_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>start
</pre></div>
</div>
<img alt="_images/5075a5956aae4dc2e0239c51c12deb0ef7c80ca60417bce66eafeaf6e015a249.svg" src="_images/5075a5956aae4dc2e0239c51c12deb0ef7c80ca60417bce66eafeaf6e015a249.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>expr
</pre></div>
</div>
<img alt="_images/9664723dea4f01755879b660e9465599031d4f177b0424cec1d15c2f7230c4c1.svg" src="_images/9664723dea4f01755879b660e9465599031d4f177b0424cec1d15c2f7230c4c1.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>integer
</pre></div>
</div>
<img alt="_images/5a75993e5ed69c1b52c21d919b3e1c6d999e993369f42728385683101967b614.svg" src="_images/5a75993e5ed69c1b52c21d919b3e1c6d999e993369f42728385683101967b614.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>digit
</pre></div>
</div>
<img alt="_images/831527e2b2231b00574fb7a68ba1dce71a738444df89dc5f1c870b2354eef828.svg" src="_images/831527e2b2231b00574fb7a68ba1dce71a738444df89dc5f1c870b2354eef828.svg" />
</div>
</div>
<p>In the above expression, the rule <code class="docutils literal notranslate"><span class="pre">&lt;expr&gt;</span> <span class="pre">:</span> <span class="pre">[&lt;expr&gt;+&lt;expr&gt;,&lt;expr&gt;-&lt;expr&gt;,&lt;integer&gt;]</span></code> corresponds to how the nonterminal <code class="docutils literal notranslate"><span class="pre">&lt;expr&gt;</span></code> might be expanded.  The expression <code class="docutils literal notranslate"><span class="pre">&lt;expr&gt;+&lt;expr&gt;</span></code> corresponds to one of the alternative choices. We call this an <em>alternative</em> expansion for the nonterminal <code class="docutils literal notranslate"><span class="pre">&lt;expr&gt;</span></code>. Finally, in an expression <code class="docutils literal notranslate"><span class="pre">&lt;expr&gt;+&lt;expr&gt;</span></code>, each of <code class="docutils literal notranslate"><span class="pre">&lt;expr&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, and <code class="docutils literal notranslate"><span class="pre">&lt;expr&gt;</span></code> are <em>symbols</em> in that expansion. A symbol could be either a nonterminal or a terminal symbol based on whether its expansion is available in the grammar.</p>
<p>Here is a string that represents an arithmetic expression that we would like to parse, which is specified by the grammar above:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s1">&#39;1+2&#39;</span>
</pre></div>
</div>
</div>
</div>
<p>The <em>derivation tree</em> for our expression from this grammar is given by:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tree</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;&lt;expr&gt;&#39;</span><span class="p">,</span>
                     <span class="p">[(</span><span class="s1">&#39;&lt;expr&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;&lt;integer&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;&lt;digit&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="p">[])])])]),</span>
                      <span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="p">[]),</span>
                      <span class="p">(</span><span class="s1">&#39;&lt;expr&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;&lt;integer&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;&lt;digit&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span>
                                                               <span class="p">[])])])])])])</span>
<span class="k">assert</span> <span class="n">mystring</span> <span class="o">==</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/a9f332bf30d389a4539611ed4a1dcb9da07c05a7840e2d175be9a8c2b5e9788f.svg" src="_images/a9f332bf30d389a4539611ed4a1dcb9da07c05a7840e2d175be9a8c2b5e9788f.svg" />
</div>
</div>
<p>While a grammar can be used to specify a given language, there could be multiple
grammars that correspond to the same language. For example, here is another
grammar to describe the same addition expression.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A2_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;&lt;start&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;expr&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;expr&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;integer&gt;&lt;expr_&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;expr_&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;+&lt;expr&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;-&lt;expr&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;integer&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;digit&gt;&lt;integer_&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;integer_&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;integer&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;digit&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">,</span> <span class="s2">&quot;4&quot;</span><span class="p">,</span> <span class="s2">&quot;5&quot;</span><span class="p">,</span> <span class="s2">&quot;6&quot;</span><span class="p">,</span> <span class="s2">&quot;7&quot;</span><span class="p">,</span> <span class="s2">&quot;8&quot;</span><span class="p">,</span> <span class="s2">&quot;9&quot;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">syntax_diagram</span><span class="p">(</span><span class="n">A2_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>start
</pre></div>
</div>
<img alt="_images/5075a5956aae4dc2e0239c51c12deb0ef7c80ca60417bce66eafeaf6e015a249.svg" src="_images/5075a5956aae4dc2e0239c51c12deb0ef7c80ca60417bce66eafeaf6e015a249.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>expr
</pre></div>
</div>
<img alt="_images/a8f7e69082ae5077c935be3f568167d0dc41c0b33413b1aa9c6ecce6adb3ee7b.svg" src="_images/a8f7e69082ae5077c935be3f568167d0dc41c0b33413b1aa9c6ecce6adb3ee7b.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>expr_
</pre></div>
</div>
<img alt="_images/6645d925131dd486ea34d64b960cc69da3cf711ed10d7d3e141fcda14d082fa8.svg" src="_images/6645d925131dd486ea34d64b960cc69da3cf711ed10d7d3e141fcda14d082fa8.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>integer
</pre></div>
</div>
<img alt="_images/89e3c72a90a520643fb63e3d60440af26e6e00f2e175650a3deb271ed9ffab29.svg" src="_images/89e3c72a90a520643fb63e3d60440af26e6e00f2e175650a3deb271ed9ffab29.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>integer_
</pre></div>
</div>
<img alt="_images/164044b79271d25dbf10a30674aef0b878609d8ba246721ce203d023a1a8623a.svg" src="_images/164044b79271d25dbf10a30674aef0b878609d8ba246721ce203d023a1a8623a.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>digit
</pre></div>
</div>
<img alt="_images/831527e2b2231b00574fb7a68ba1dce71a738444df89dc5f1c870b2354eef828.svg" src="_images/831527e2b2231b00574fb7a68ba1dce71a738444df89dc5f1c870b2354eef828.svg" />
</div>
</div>
<p>The corresponding derivation tree is given by:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tree</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;&lt;expr&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;&lt;integer&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;&lt;digit&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="p">[])]),</span>
                                               <span class="p">(</span><span class="s1">&#39;&lt;integer_&gt;&#39;</span><span class="p">,</span> <span class="p">[])]),</span>
                                <span class="p">(</span><span class="s1">&#39;&lt;expr_&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="p">[]),</span>
                                             <span class="p">(</span><span class="s1">&#39;&lt;expr&gt;&#39;</span><span class="p">,</span>
                                              <span class="p">[(</span><span class="s1">&#39;&lt;integer&gt;&#39;</span><span class="p">,</span>
                                                <span class="p">[(</span><span class="s1">&#39;&lt;digit&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="p">[])]),</span>
                                                 <span class="p">(</span><span class="s1">&#39;&lt;integer_&gt;&#39;</span><span class="p">,</span> <span class="p">[])]),</span>
                                               <span class="p">(</span><span class="s1">&#39;&lt;expr_&gt;&#39;</span><span class="p">,</span> <span class="p">[])])])])])</span>
<span class="k">assert</span> <span class="n">mystring</span> <span class="o">==</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/195c443bafcc41bb128d6d55b1d3af3904ce086b3f9f27d4e147af0908a9fd93.svg" src="_images/195c443bafcc41bb128d6d55b1d3af3904ce086b3f9f27d4e147af0908a9fd93.svg" />
</div>
</div>
<p>Indeed, there could be different classes of grammars that
describe the same language. For example, the first grammar <code class="docutils literal notranslate"><span class="pre">A1_GRAMMAR</span></code>
is a grammar that sports both <em>right</em> and <em>left</em> recursion, while the
second grammar <code class="docutils literal notranslate"><span class="pre">A2_GRAMMAR</span></code> does not have left recursion in the
nonterminals in any of its productions, but contains <em>epsilon</em> productions.
(An epsilon production is a production that has empty string in its right-hand side.)</p>
</section>
<section id="end-of-excursion">
<h3>End of Excursion<a class="headerlink" href="#end-of-excursion" title="Link to this heading">#</a></h3>
</section>
<section id="excursion-recursion">
<h3>Excursion: Recursion<a class="headerlink" href="#excursion-recursion" title="Link to this heading">#</a></h3>
<p>You would have noticed that we reuse the term <code class="docutils literal notranslate"><span class="pre">&lt;expr&gt;</span></code> in its own definition. Using the same nonterminal in its own definition is called <em>recursion</em>. There are two specific kinds of recursion one should be aware of in parsing, as we see in the next section.</p>
<section id="recursion">
<h4>Recursion<a class="headerlink" href="#recursion" title="Link to this heading">#</a></h4>
<p>A grammar is <em>left recursive</em> if any of its nonterminals are left recursive,
and a nonterminal is <em>directly left-recursive</em> if the left-most symbol of
any of its productions is itself.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">LR_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;A&gt;a&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">],</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">syntax_diagram</span><span class="p">(</span><span class="n">LR_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>start
</pre></div>
</div>
<img alt="_images/910810b0e5cbca3148f660f4a0942c82e721e8738a0be383e7b22c107141ddd5.svg" src="_images/910810b0e5cbca3148f660f4a0942c82e721e8738a0be383e7b22c107141ddd5.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>A
</pre></div>
</div>
<img alt="_images/92b634049fbe08a4e9148b04533def0b9bd33ff4149082e4c4462b1c38c97024.svg" src="_images/92b634049fbe08a4e9148b04533def0b9bd33ff4149082e4c4462b1c38c97024.svg" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s1">&#39;aaaaaa&#39;</span>
<span class="n">display_tree</span><span class="p">(</span>
    <span class="p">(</span><span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">,</span> <span class="p">[]),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">[])]),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">[])]),</span>
                 <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">[])]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/90aff9327e89e8ff36d8e50d3222613b1be7a75654cbe1ee2e503d36f5df0cce.svg" src="_images/90aff9327e89e8ff36d8e50d3222613b1be7a75654cbe1ee2e503d36f5df0cce.svg" />
</div>
</div>
<p>A grammar is indirectly left-recursive if any
of the left-most symbols can be expanded using their definitions to
produce the nonterminal as the left-most symbol of the expansion. The left
recursion is called a <em>hidden-left-recursion</em> if during the series of
expansions of a nonterminal, one reaches a rule where the rule contains
the same nonterminal after a prefix of other symbols, and these symbols can
derive the empty string. For example, in <code class="docutils literal notranslate"><span class="pre">A1_GRAMMAR</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;integer&gt;</span></code> will be
considered hidden-left recursive if <code class="docutils literal notranslate"><span class="pre">&lt;digit&gt;</span></code> could derive an empty string.</p>
<p>Right recursive grammars are defined similarly.
Below is the derivation tree for the right recursive grammar that represents the same
language as that of <code class="docutils literal notranslate"><span class="pre">LR_GRAMMAR</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">RR_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&lt;A&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">],</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">syntax_diagram</span><span class="p">(</span><span class="n">RR_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>start
</pre></div>
</div>
<img alt="_images/910810b0e5cbca3148f660f4a0942c82e721e8738a0be383e7b22c107141ddd5.svg" src="_images/910810b0e5cbca3148f660f4a0942c82e721e8738a0be383e7b22c107141ddd5.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>A
</pre></div>
</div>
<img alt="_images/722cdfe9293291db58935ba260fbb7fb1111e0a00a051c0f759750db03a0ec9e.svg" src="_images/722cdfe9293291db58935ba260fbb7fb1111e0a00a051c0f759750db03a0ec9e.svg" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">display_tree</span><span class="p">((</span><span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">,</span> <span class="p">[</span>
                  <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">[]),</span> <span class="p">(</span><span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">[]),</span> <span class="p">(</span><span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">[]),</span> <span class="p">(</span><span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">,</span> <span class="p">[])])])])]</span>
             <span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/669dc5c05eb8ba2f029cb67c8169e00ea28536139dbfbffdd1ec9af29615091e.svg" src="_images/669dc5c05eb8ba2f029cb67c8169e00ea28536139dbfbffdd1ec9af29615091e.svg" />
</div>
</div>
</section>
<section id="ambiguity">
<h4>Ambiguity<a class="headerlink" href="#ambiguity" title="Link to this heading">#</a></h4>
<p>To complicate matters further, there could be
multiple derivation trees – also called <em>parses</em> – corresponding to the
same string from the same grammar. For example, a string <code class="docutils literal notranslate"><span class="pre">1+2+3</span></code> can be parsed
in two ways as we see below using the <code class="docutils literal notranslate"><span class="pre">A1_GRAMMAR</span></code></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s1">&#39;1+2+3&#39;</span>
<span class="n">tree</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">,</span>
        <span class="p">[(</span><span class="s1">&#39;&lt;expr&gt;&#39;</span><span class="p">,</span>
          <span class="p">[(</span><span class="s1">&#39;&lt;expr&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;&lt;expr&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;&lt;integer&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;&lt;digit&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="p">[])])])]),</span>
                       <span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="p">[]),</span>
                       <span class="p">(</span><span class="s1">&#39;&lt;expr&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;&lt;integer&gt;&#39;</span><span class="p">,</span>
                                    <span class="p">[(</span><span class="s1">&#39;&lt;digit&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="p">[])])])])]),</span> <span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="p">[]),</span>
           <span class="p">(</span><span class="s1">&#39;&lt;expr&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;&lt;integer&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;&lt;digit&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="p">[])])])])])])</span>
<span class="k">assert</span> <span class="n">mystring</span> <span class="o">==</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ace4b3c9f4aefc8d82436ba94d28395991569e456836e23b8ae3fbad19ac4c9e.svg" src="_images/ace4b3c9f4aefc8d82436ba94d28395991569e456836e23b8ae3fbad19ac4c9e.svg" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tree</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">,</span>
        <span class="p">[(</span><span class="s1">&#39;&lt;expr&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;&lt;expr&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;&lt;integer&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;&lt;digit&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="p">[])])])]),</span>
                     <span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="p">[]),</span>
                     <span class="p">(</span><span class="s1">&#39;&lt;expr&gt;&#39;</span><span class="p">,</span>
                      <span class="p">[(</span><span class="s1">&#39;&lt;expr&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;&lt;integer&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;&lt;digit&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="p">[])])])]),</span>
                       <span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="p">[]),</span>
                       <span class="p">(</span><span class="s1">&#39;&lt;expr&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;&lt;integer&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;&lt;digit&gt;&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;3&#39;</span><span class="p">,</span>
                                                                <span class="p">[])])])])])])])</span>
<span class="k">assert</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="n">mystring</span>
<span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/504ffc636b302a1d2223572d0b06f568ec8d1dbc841e0d7a7d62540fc0a849ec.svg" src="_images/504ffc636b302a1d2223572d0b06f568ec8d1dbc841e0d7a7d62540fc0a849ec.svg" />
</div>
</div>
<p>There are many ways to resolve ambiguities. One approach taken by <em>Parsing Expression Grammars</em> explained in the next section is to specify a particular order of resolution, and choose the first one. Another approach is to simply return all possible derivation trees, which is the approach taken by <em>Earley parser</em> we develop later.</p>
</section>
</section>
<section id="id1">
<h3>End of Excursion<a class="headerlink" href="#id1" title="Link to this heading">#</a></h3>
</section>
</section>
<section id="a-parser-class">
<h2>A Parser Class<a class="headerlink" href="#a-parser-class" title="Link to this heading">#</a></h2>
<p>Next, we develop different parsers. To do that, we define a minimal interface for parsing that is obeyed by all parsers. There are two approaches to parsing a string using a grammar.</p>
<ol class="arabic simple">
<li><p>The traditional approach is to use a <em>lexer</em> (also called a <em>tokenizer</em> or a <em>scanner</em>) to first tokenize the incoming string, and feed the grammar one token at a time. The lexer is typically a smaller parser that accepts a <em>regular language</em>. The advantage of this approach is that the grammar used by the parser can eschew the details of tokenization. Further, one gets a shallow derivation tree at the end of the parsing which can be directly used for generating the <em>Abstract Syntax Tree</em>.</p></li>
<li><p>The second approach is to use a tree pruner after the complete parse. With this approach, one uses a grammar that incorporates complete details of the syntax. Next, the nodes corresponding to tokens are pruned and replaced with their corresponding strings as leaf nodes. The utility of this approach is that the parser is more powerful, and further there is no artificial distinction between <em>lexing</em> and <em>parsing</em>.</p></li>
</ol>
<p>In this chapter, we use the second approach. This approach is implemented in the <code class="docutils literal notranslate"><span class="pre">prune_tree</span></code> method.</p>
<p>The <em>Parser</em> class we define below provides the minimal interface. The main methods that need to be implemented by the classes implementing this interface are <code class="docutils literal notranslate"><span class="pre">parse_prefix</span></code> and <code class="docutils literal notranslate"><span class="pre">parse</span></code>. The <code class="docutils literal notranslate"><span class="pre">parse_prefix</span></code> returns a tuple, which contains the index until which parsing was completed successfully, and the parse forest until that index. The method <code class="docutils literal notranslate"><span class="pre">parse</span></code> returns a list of derivation trees if the parse was successful.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parser</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for parsing.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                 <span class="n">start_symbol</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">START_SYMBOL</span><span class="p">,</span>
                 <span class="n">log</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">coalesce</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                 <span class="n">tokens</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">())</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructor.</span>
<span class="sd">           `grammar` is the grammar to be used for parsing.</span>
<span class="sd">           Keyword arguments:</span>
<span class="sd">           `start_symbol` is the start symbol (default: &#39;&lt;start&gt;&#39;).</span>
<span class="sd">           `log` enables logging (default: False).</span>
<span class="sd">           `coalesce` defines if tokens should be coalesced (default: True).</span>
<span class="sd">           `tokens`, if set, is a set of tokens to be used.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span> <span class="o">=</span> <span class="n">grammar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start_symbol</span> <span class="o">=</span> <span class="n">start_symbol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">log</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coalesce_tokens</span> <span class="o">=</span> <span class="n">coalesce</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span> <span class="o">=</span> <span class="n">tokens</span>

    <span class="k">def</span> <span class="nf">grammar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Grammar</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the grammar of this parser.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span>

    <span class="k">def</span> <span class="nf">start_symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the start symbol of this parser.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start_symbol</span>

    <span class="k">def</span> <span class="nf">parse_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return pair (cursor, forest) for longest prefix of text. </span>
<span class="sd">           To be defined in subclasses.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse `text` using the grammar. </span>
<span class="sd">           Return an iterable of parse trees.&quot;&quot;&quot;</span>
        <span class="n">cursor</span><span class="p">,</span> <span class="n">forest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_prefix</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cursor</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s2">&quot;at &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">cursor</span><span class="p">:]))</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">prune_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">forest</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">parse_on</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">start_symbol</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">:</span>
        <span class="n">old_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start_symbol</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_start_symbol</span> <span class="o">=</span> <span class="n">start_symbol</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_start_symbol</span> <span class="o">=</span> <span class="n">old_start</span>

    <span class="k">def</span> <span class="nf">coalesce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">children</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">]:</span>
        <span class="n">last</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">new_lst</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cn</span><span class="p">,</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cn</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span><span class="p">:</span>
                <span class="n">last</span> <span class="o">+=</span> <span class="n">cn</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">last</span><span class="p">:</span>
                    <span class="n">new_lst</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">last</span><span class="p">,</span> <span class="p">[]))</span>
                    <span class="n">last</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                <span class="n">new_lst</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cn</span><span class="p">,</span> <span class="n">cc</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">last</span><span class="p">:</span>
            <span class="n">new_lst</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">last</span><span class="p">,</span> <span class="p">[]))</span>
        <span class="k">return</span> <span class="n">new_lst</span>

    <span class="k">def</span> <span class="nf">prune_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">DerivationTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DerivationTree</span><span class="p">:</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">children</span> <span class="o">=</span> <span class="n">tree</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coalesce_tokens</span><span class="p">:</span>
            <span class="n">children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coalesce</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">],</span> <span class="n">children</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">[(</span><span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">),</span> <span class="p">[])])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">prune_tree</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<section id="excursion-canonical-grammars">
<h3>Excursion: Canonical Grammars<a class="headerlink" href="#excursion-canonical-grammars" title="Link to this heading">#</a></h3>
<p>The  <code class="docutils literal notranslate"><span class="pre">EXPR_GRAMMAR</span></code> we import from the <a class="reference internal" href="Grammars.html"><span class="std std-doc">chapter on grammars</span></a> is oriented towards generation. In particular, the production rules are stored as strings. We need to massage this representation a little to conform to a <em>canonical representation</em> where each token in a rule is represented separately. The <code class="docutils literal notranslate"><span class="pre">canonical</span></code> format uses separate tokens to represent each symbol in an expansion.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">CanonicalGrammar</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">single_char_tokens</span><span class="p">(</span><span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Collection</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]]:</span>
    <span class="n">g_</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">grammar</span><span class="p">:</span>
        <span class="n">rules_</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">grammar</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
            <span class="n">rule_</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">rule</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">grammar</span><span class="p">:</span>
                    <span class="n">rule_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rule_</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
            <span class="n">rules_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rule_</span><span class="p">)</span>
        <span class="n">g_</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">rules_</span>
    <span class="k">return</span> <span class="n">g_</span>  <span class="c1"># type: ignore</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">canonical</span><span class="p">(</span><span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CanonicalGrammar</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="n">expansion</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expansion</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">expansion</span> <span class="o">=</span> <span class="n">expansion</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">token</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
            <span class="n">RE_NONTERMINAL</span><span class="p">,</span> <span class="n">expansion</span><span class="p">)</span> <span class="k">if</span> <span class="n">token</span><span class="p">]</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="n">k</span><span class="p">:</span> <span class="p">[</span><span class="n">split</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span> <span class="k">for</span> <span class="n">expression</span> <span class="ow">in</span> <span class="n">alternatives</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">alternatives</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">CE_GRAMMAR</span><span class="p">:</span> <span class="n">CanonicalGrammar</span> <span class="o">=</span> <span class="n">canonical</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
<span class="n">CE_GRAMMAR</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;&lt;start&gt;&#39;: [[&#39;&lt;expr&gt;&#39;]],
 &#39;&lt;expr&gt;&#39;: [[&#39;&lt;term&gt;&#39;, &#39; + &#39;, &#39;&lt;expr&gt;&#39;],
  [&#39;&lt;term&gt;&#39;, &#39; - &#39;, &#39;&lt;expr&gt;&#39;],
  [&#39;&lt;term&gt;&#39;]],
 &#39;&lt;term&gt;&#39;: [[&#39;&lt;factor&gt;&#39;, &#39; * &#39;, &#39;&lt;term&gt;&#39;],
  [&#39;&lt;factor&gt;&#39;, &#39; / &#39;, &#39;&lt;term&gt;&#39;],
  [&#39;&lt;factor&gt;&#39;]],
 &#39;&lt;factor&gt;&#39;: [[&#39;+&#39;, &#39;&lt;factor&gt;&#39;],
  [&#39;-&#39;, &#39;&lt;factor&gt;&#39;],
  [&#39;(&#39;, &#39;&lt;expr&gt;&#39;, &#39;)&#39;],
  [&#39;&lt;integer&gt;&#39;, &#39;.&#39;, &#39;&lt;integer&gt;&#39;],
  [&#39;&lt;integer&gt;&#39;]],
 &#39;&lt;integer&gt;&#39;: [[&#39;&lt;digit&gt;&#39;, &#39;&lt;integer&gt;&#39;], [&#39;&lt;digit&gt;&#39;]],
 &#39;&lt;digit&gt;&#39;: [[&#39;0&#39;],
  [&#39;1&#39;],
  [&#39;2&#39;],
  [&#39;3&#39;],
  [&#39;4&#39;],
  [&#39;5&#39;],
  [&#39;6&#39;],
  [&#39;7&#39;],
  [&#39;8&#39;],
  [&#39;9&#39;]]}
</pre></div>
</div>
</div>
</div>
<p>We also provide a convenience method for easier display of canonical grammars.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">recurse_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
    <span class="n">rules</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">grammar</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
    <span class="n">old_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">rules</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">rule</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">token</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">grammar</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">if</span> <span class="n">token</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">order</span><span class="p">:</span>
                <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
    <span class="n">new</span> <span class="o">=</span> <span class="n">order</span><span class="p">[</span><span class="n">old_len</span><span class="p">:]</span>
    <span class="k">for</span> <span class="n">ckey</span> <span class="ow">in</span> <span class="n">new</span><span class="p">:</span>
        <span class="n">recurse_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">ckey</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">show_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="n">START_SYMBOL</span><span class="p">):</span>
    <span class="n">order</span> <span class="o">=</span> <span class="p">[</span><span class="n">start_symbol</span><span class="p">]</span>
    <span class="n">recurse_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">start_symbol</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">grammar</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">order</span><span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">show_grammar</span><span class="p">(</span><span class="n">CE_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;&lt;start&gt;&#39;: [[&#39;&lt;expr&gt;&#39;]],
 &#39;&lt;expr&gt;&#39;: [[&#39;&lt;term&gt;&#39;],
  [&#39;&lt;term&gt;&#39;, &#39; + &#39;, &#39;&lt;expr&gt;&#39;],
  [&#39;&lt;term&gt;&#39;, &#39; - &#39;, &#39;&lt;expr&gt;&#39;]],
 &#39;&lt;term&gt;&#39;: [[&#39;&lt;factor&gt;&#39;],
  [&#39;&lt;factor&gt;&#39;, &#39; * &#39;, &#39;&lt;term&gt;&#39;],
  [&#39;&lt;factor&gt;&#39;, &#39; / &#39;, &#39;&lt;term&gt;&#39;]],
 &#39;&lt;factor&gt;&#39;: [[&#39;(&#39;, &#39;&lt;expr&gt;&#39;, &#39;)&#39;],
  [&#39;+&#39;, &#39;&lt;factor&gt;&#39;],
  [&#39;-&#39;, &#39;&lt;factor&gt;&#39;],
  [&#39;&lt;integer&gt;&#39;],
  [&#39;&lt;integer&gt;&#39;, &#39;.&#39;, &#39;&lt;integer&gt;&#39;]],
 &#39;&lt;integer&gt;&#39;: [[&#39;&lt;digit&gt;&#39;], [&#39;&lt;digit&gt;&#39;, &#39;&lt;integer&gt;&#39;]],
 &#39;&lt;digit&gt;&#39;: [[&#39;0&#39;],
  [&#39;1&#39;],
  [&#39;2&#39;],
  [&#39;3&#39;],
  [&#39;4&#39;],
  [&#39;5&#39;],
  [&#39;6&#39;],
  [&#39;7&#39;],
  [&#39;8&#39;],
  [&#39;9&#39;]]}
</pre></div>
</div>
</div>
</div>
<p>We provide a way to revert a canonical expression.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">non_canonical</span><span class="p">(</span><span class="n">grammar</span><span class="p">):</span>
    <span class="n">new_grammar</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">grammar</span><span class="p">:</span>
        <span class="n">rules</span> <span class="o">=</span> <span class="n">grammar</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">new_rules</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">rules</span><span class="p">:</span>
            <span class="n">new_rules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rule</span><span class="p">))</span>
        <span class="n">new_grammar</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_rules</span>
    <span class="k">return</span> <span class="n">new_grammar</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">non_canonical</span><span class="p">(</span><span class="n">CE_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;&lt;start&gt;&#39;: [&#39;&lt;expr&gt;&#39;],
 &#39;&lt;expr&gt;&#39;: [&#39;&lt;term&gt; + &lt;expr&gt;&#39;, &#39;&lt;term&gt; - &lt;expr&gt;&#39;, &#39;&lt;term&gt;&#39;],
 &#39;&lt;term&gt;&#39;: [&#39;&lt;factor&gt; * &lt;term&gt;&#39;, &#39;&lt;factor&gt; / &lt;term&gt;&#39;, &#39;&lt;factor&gt;&#39;],
 &#39;&lt;factor&gt;&#39;: [&#39;+&lt;factor&gt;&#39;,
  &#39;-&lt;factor&gt;&#39;,
  &#39;(&lt;expr&gt;)&#39;,
  &#39;&lt;integer&gt;.&lt;integer&gt;&#39;,
  &#39;&lt;integer&gt;&#39;],
 &#39;&lt;integer&gt;&#39;: [&#39;&lt;digit&gt;&lt;integer&gt;&#39;, &#39;&lt;digit&gt;&#39;],
 &#39;&lt;digit&gt;&#39;: [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;]}
</pre></div>
</div>
</div>
</div>
<p>It is easier to work with the <code class="docutils literal notranslate"><span class="pre">canonical</span></code> representation during parsing. Hence, we update our parser class to store the <code class="docutils literal notranslate"><span class="pre">canonical</span></code> representation also.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parser</span><span class="p">(</span><span class="n">Parser</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start_symbol</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;start_symbol&#39;</span><span class="p">,</span> <span class="n">START_SYMBOL</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;tokens&#39;</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coalesce_tokens</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;coalesce&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">canonical_grammar</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;canonical&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">canonical_grammar</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cgrammar</span> <span class="o">=</span> <span class="n">single_char_tokens</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span> <span class="o">=</span> <span class="n">non_canonical</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cgrammar</span> <span class="o">=</span> <span class="n">single_char_tokens</span><span class="p">(</span><span class="n">canonical</span><span class="p">(</span><span class="n">grammar</span><span class="p">))</span>
        <span class="c1"># we do not require a single rule for the start symbol</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_start_symbol</span><span class="p">,</span> <span class="p">[]))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cgrammar</span><span class="p">[</span><span class="s1">&#39;&lt;&gt;&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">_start_symbol</span><span class="p">]]</span>
</pre></div>
</div>
</div>
</div>
<p>We update the <code class="docutils literal notranslate"><span class="pre">prune_tree()</span></code> to account for the phony start symbol if it was insserted.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parser</span><span class="p">(</span><span class="n">Parser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">prune_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">children</span> <span class="o">=</span> <span class="n">tree</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;&lt;&gt;&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">prune_tree</span><span class="p">(</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coalesce_tokens</span><span class="p">:</span>
            <span class="n">children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coalesce</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">[(</span><span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">),</span> <span class="p">[])])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">prune_tree</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="id2">
<h3>End of Excursion<a class="headerlink" href="#id2" title="Link to this heading">#</a></h3>
</section>
</section>
<section id="parsing-expression-grammars">
<h2>Parsing Expression Grammars<a class="headerlink" href="#parsing-expression-grammars" title="Link to this heading">#</a></h2>
<p>A <em><a class="reference external" href="http://bford.info/pub/lang/peg">Parsing Expression Grammar</a></em> (<em>PEG</em>) \cite{Ford2004} is a type of <em>recognition based formal grammar</em> that specifies the sequence of steps to take to parse a given string.
A <em>parsing expression grammar</em> is very similar to a <em>context-free grammar</em> (<em>CFG</em>) such as the ones we saw in the <a class="reference internal" href="Grammars.html"><span class="std std-doc">chapter on grammars</span></a>. As in a CFG, a parsing expression grammar is represented by a set of nonterminals and corresponding alternatives representing how to match each. For example, here is a PEG that matches <code class="docutils literal notranslate"><span class="pre">a</span></code> or <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">PEG1</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>However, unlike the <em>CFG</em>, the alternatives represent <em>ordered choice</em>. That is, rather than choosing all rules that can potentially match, we stop at the first match that succeed. For example, the below <em>PEG</em> can match <code class="docutils literal notranslate"><span class="pre">ab</span></code> but not <code class="docutils literal notranslate"><span class="pre">abc</span></code> unlike a <em>CFG</em> which will match both. (We call the sequence of ordered choice expressions <em>choice expressions</em>  rather than alternatives to make the distinction from <em>CFG</em> clear.)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">PEG2</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;ab&#39;</span><span class="p">,</span> <span class="s1">&#39;abc&#39;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>Each choice in a <em>choice expression</em> represents a rule on how to satisfy that particular choice. The choice is a sequence of symbols (terminals and nonterminals) that are matched against a given text as in a <em>CFG</em>.</p>
<p>Beyond the syntax of grammar definitions we have seen so far, a <em>PEG</em> can also contain a few additional elements. See the exercises at the end of the chapter for additional information.</p>
<p>The PEGs model the typical practice in handwritten recursive descent parsers, and hence it may be considered more intuitive to understand.</p>
<section id="the-packrat-parser-for-predicate-expression-grammars">
<h3>The Packrat Parser for Predicate Expression Grammars<a class="headerlink" href="#the-packrat-parser-for-predicate-expression-grammars" title="Link to this heading">#</a></h3>
<p>Short of hand rolling a parser, <em>Packrat</em> parsing is one of the simplest parsing techniques, and is one of the techniques for parsing PEGs.
The <em>Packrat</em> parser is so named because it tries to cache all results from simpler problems in the hope that these solutions can be used to avoid re-computation later. We develop a minimal <em>Packrat</em> parser next.</p>
<p>We derive from the <code class="docutils literal notranslate"><span class="pre">Parser</span></code> base class first, and we accept the text to be parsed in the <code class="docutils literal notranslate"><span class="pre">parse()</span></code> method, which in turn calls <code class="docutils literal notranslate"><span class="pre">unify_key()</span></code> with the <code class="docutils literal notranslate"><span class="pre">start_symbol</span></code>.</p>
<p><strong>Note.</strong> While our PEG parser can produce only a single unambiguous parse tree, other parsers can produce multiple parses for ambiguous grammars. Hence, we return a list of trees (in this case with a single element).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PEGParser</span><span class="p">(</span><span class="n">Parser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">parse_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="n">cursor</span><span class="p">,</span> <span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unify_key</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_symbol</span><span class="p">(),</span> <span class="n">text</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cursor</span><span class="p">,</span> <span class="p">[</span><span class="n">tree</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="excursion-implementing-pegparser">
<h3>Excursion: Implementing <code class="docutils literal notranslate"><span class="pre">PEGParser</span></code><a class="headerlink" href="#excursion-implementing-pegparser" title="Link to this heading">#</a></h3>
<section id="unify-key">
<h4>Unify Key<a class="headerlink" href="#unify-key" title="Link to this heading">#</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">unify_key()</span></code> algorithm is simple. If given a terminal symbol, it tries to match the symbol with the current position in the text. If the symbol and text match, it returns successfully with the new parse index <code class="docutils literal notranslate"><span class="pre">at</span></code>.</p>
<p>If on the other hand, it was given a nonterminal, it retrieves the choice expression corresponding to the key, and tries to match each choice <em>in order</em> using <code class="docutils literal notranslate"><span class="pre">unify_rule()</span></code>. If <strong>any</strong> of the rules succeed in being unified with the given text, the parse is considered a success, and we return with the new parse index returned by <code class="docutils literal notranslate"><span class="pre">unify_rule()</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PEGParser</span><span class="p">(</span><span class="n">PEGParser</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Packrat parser for Parsing Expression Grammars (PEGs).&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">unify_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">at</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;unify_key: </span><span class="si">%s</span><span class="s2"> with </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">at</span><span class="p">:])))</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cgrammar</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="n">at</span><span class="p">:]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">at</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">at</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cgrammar</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
            <span class="n">to</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unify_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">at</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">res</span><span class="p">))</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s2">&quot;1&quot;</span>
<span class="n">peg</span> <span class="o">=</span> <span class="n">PEGParser</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">peg</span><span class="o">.</span><span class="n">unify_key</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="n">mystring</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>unify_key: &#39;1&#39; with &#39;1&#39;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(1, (&#39;1&#39;, []))
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s2">&quot;2&quot;</span>
<span class="n">peg</span><span class="o">.</span><span class="n">unify_key</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="n">mystring</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>unify_key: &#39;1&#39; with &#39;2&#39;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(0, None)
</pre></div>
</div>
</div>
</div>
</section>
<section id="unify-rule">
<h4>Unify Rule<a class="headerlink" href="#unify-rule" title="Link to this heading">#</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">unify_rule()</span></code> method is similar. It retrieves the tokens corresponding to the rule that it needs to unify with the text, and calls <code class="docutils literal notranslate"><span class="pre">unify_key()</span></code> on them in sequence. If <strong>all</strong> tokens are successfully unified with the text, the parse is a success.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PEGParser</span><span class="p">(</span><span class="n">PEGParser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">unify_rule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">at</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;unify_rule: </span><span class="si">%s</span><span class="s1"> with </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">rule</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">at</span><span class="p">:])))</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">rule</span><span class="p">:</span>
            <span class="n">at</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unify_key</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">at</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">at</span><span class="p">,</span> <span class="kc">None</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">at</span><span class="p">,</span> <span class="n">results</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span>
<span class="n">peg</span> <span class="o">=</span> <span class="n">PEGParser</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">peg</span><span class="o">.</span><span class="n">unify_rule</span><span class="p">(</span><span class="n">peg</span><span class="o">.</span><span class="n">cgrammar</span><span class="p">[</span><span class="s1">&#39;&lt;digit&gt;&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">mystring</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>unify_rule: [&#39;0&#39;] with &#39;0&#39;
unify_key: &#39;0&#39; with &#39;0&#39;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(1, [(&#39;0&#39;, [])])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s2">&quot;12&quot;</span>
<span class="n">peg</span><span class="o">.</span><span class="n">unify_rule</span><span class="p">(</span><span class="n">peg</span><span class="o">.</span><span class="n">cgrammar</span><span class="p">[</span><span class="s1">&#39;&lt;integer&gt;&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">mystring</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>unify_rule: [&#39;&lt;digit&gt;&#39;, &#39;&lt;integer&gt;&#39;] with &#39;12&#39;
unify_key: &#39;&lt;digit&gt;&#39; with &#39;12&#39;
unify_rule: [&#39;0&#39;] with &#39;12&#39;
unify_key: &#39;0&#39; with &#39;12&#39;
unify_rule: [&#39;1&#39;] with &#39;12&#39;
unify_key: &#39;1&#39; with &#39;12&#39;
unify_key: &#39;&lt;integer&gt;&#39; with &#39;2&#39;
unify_rule: [&#39;&lt;digit&gt;&#39;, &#39;&lt;integer&gt;&#39;] with &#39;2&#39;
unify_key: &#39;&lt;digit&gt;&#39; with &#39;2&#39;
unify_rule: [&#39;0&#39;] with &#39;2&#39;
unify_key: &#39;0&#39; with &#39;2&#39;
unify_rule: [&#39;1&#39;] with &#39;2&#39;
unify_key: &#39;1&#39; with &#39;2&#39;
unify_rule: [&#39;2&#39;] with &#39;2&#39;
unify_key: &#39;2&#39; with &#39;2&#39;
unify_key: &#39;&lt;integer&gt;&#39; with &#39;&#39;
unify_rule: [&#39;&lt;digit&gt;&#39;, &#39;&lt;integer&gt;&#39;] with &#39;&#39;
unify_key: &#39;&lt;digit&gt;&#39; with &#39;&#39;
unify_rule: [&#39;0&#39;] with &#39;&#39;
unify_key: &#39;0&#39; with &#39;&#39;
unify_rule: [&#39;1&#39;] with &#39;&#39;
unify_key: &#39;1&#39; with &#39;&#39;
unify_rule: [&#39;2&#39;] with &#39;&#39;
unify_key: &#39;2&#39; with &#39;&#39;
unify_rule: [&#39;3&#39;] with &#39;&#39;
unify_key: &#39;3&#39; with &#39;&#39;
unify_rule: [&#39;4&#39;] with &#39;&#39;
unify_key: &#39;4&#39; with &#39;&#39;
unify_rule: [&#39;5&#39;] with &#39;&#39;
unify_key: &#39;5&#39; with &#39;&#39;
unify_rule: [&#39;6&#39;] with &#39;&#39;
unify_key: &#39;6&#39; with &#39;&#39;
unify_rule: [&#39;7&#39;] with &#39;&#39;
unify_key: &#39;7&#39; with &#39;&#39;
unify_rule: [&#39;8&#39;] with &#39;&#39;
unify_key: &#39;8&#39; with &#39;&#39;
unify_rule: [&#39;9&#39;] with &#39;&#39;
unify_key: &#39;9&#39; with &#39;&#39;
unify_rule: [&#39;&lt;digit&gt;&#39;] with &#39;&#39;
unify_key: &#39;&lt;digit&gt;&#39; with &#39;&#39;
unify_rule: [&#39;0&#39;] with &#39;&#39;
unify_key: &#39;0&#39; with &#39;&#39;
unify_rule: [&#39;1&#39;] with &#39;&#39;
unify_key: &#39;1&#39; with &#39;&#39;
unify_rule: [&#39;2&#39;] with &#39;&#39;
unify_key: &#39;2&#39; with &#39;&#39;
unify_rule: [&#39;3&#39;] with &#39;&#39;
unify_key: &#39;3&#39; with &#39;&#39;
unify_rule: [&#39;4&#39;] with &#39;&#39;
unify_key: &#39;4&#39; with &#39;&#39;
unify_rule: [&#39;5&#39;] with &#39;&#39;
unify_key: &#39;5&#39; with &#39;&#39;
unify_rule: [&#39;6&#39;] with &#39;&#39;
unify_key: &#39;6&#39; with &#39;&#39;
unify_rule: [&#39;7&#39;] with &#39;&#39;
unify_key: &#39;7&#39; with &#39;&#39;
unify_rule: [&#39;8&#39;] with &#39;&#39;
unify_key: &#39;8&#39; with &#39;&#39;
unify_rule: [&#39;9&#39;] with &#39;&#39;
unify_key: &#39;9&#39; with &#39;&#39;
unify_rule: [&#39;&lt;digit&gt;&#39;] with &#39;2&#39;
unify_key: &#39;&lt;digit&gt;&#39; with &#39;2&#39;
unify_rule: [&#39;0&#39;] with &#39;2&#39;
unify_key: &#39;0&#39; with &#39;2&#39;
unify_rule: [&#39;1&#39;] with &#39;2&#39;
unify_key: &#39;1&#39; with &#39;2&#39;
unify_rule: [&#39;2&#39;] with &#39;2&#39;
unify_key: &#39;2&#39; with &#39;2&#39;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(2, [(&#39;&lt;digit&gt;&#39;, [(&#39;1&#39;, [])]), (&#39;&lt;integer&gt;&#39;, [(&#39;&lt;digit&gt;&#39;, [(&#39;2&#39;, [])])])])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s2">&quot;1 + 2&quot;</span>
<span class="n">peg</span> <span class="o">=</span> <span class="n">PEGParser</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">peg</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[(&#39;&lt;start&gt;&#39;,
  [(&#39;&lt;expr&gt;&#39;,
    [(&#39;&lt;term&gt;&#39;, [(&#39;&lt;factor&gt;&#39;, [(&#39;&lt;integer&gt;&#39;, [(&#39;&lt;digit&gt;&#39;, [(&#39;1&#39;, [])])])])]),
     (&#39; + &#39;, []),
     (&#39;&lt;expr&gt;&#39;,
      [(&#39;&lt;term&gt;&#39;,
        [(&#39;&lt;factor&gt;&#39;, [(&#39;&lt;integer&gt;&#39;, [(&#39;&lt;digit&gt;&#39;, [(&#39;2&#39;, [])])])])])])])])]
</pre></div>
</div>
</div>
</div>
<p>The two methods are mutually recursive, and given that <code class="docutils literal notranslate"><span class="pre">unify_key()</span></code> tries each alternative until it succeeds, <code class="docutils literal notranslate"><span class="pre">unify_key</span></code> can be called multiple times with the same arguments. Hence, it is important to memoize the results of <code class="docutils literal notranslate"><span class="pre">unify_key</span></code>. Python provides a simple decorator <code class="docutils literal notranslate"><span class="pre">lru_cache</span></code> for memoizing any function call that has hashable arguments. We add that to our implementation so that repeated calls to <code class="docutils literal notranslate"><span class="pre">unify_key()</span></code> with the same argument get cached results.</p>
<p>This memoization gives the algorithm its name – <em>Packrat</em>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">lru_cache</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PEGParser</span><span class="p">(</span><span class="n">PEGParser</span><span class="p">):</span>
    <span class="nd">@lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">unify_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">at</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cgrammar</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="n">at</span><span class="p">:]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">at</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">at</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cgrammar</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
            <span class="n">to</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unify_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">at</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">res</span><span class="p">))</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span>
</pre></div>
</div>
</div>
</div>
<p>We wrap initialization and calling of <code class="docutils literal notranslate"><span class="pre">PEGParser</span></code> in a method <code class="docutils literal notranslate"><span class="pre">parse()</span></code> already implemented in the <code class="docutils literal notranslate"><span class="pre">Parser</span></code> base class that accepts the text to be parsed along with the grammar.</p>
</section>
</section>
<section id="id3">
<h3>End of Excursion<a class="headerlink" href="#id3" title="Link to this heading">#</a></h3>
<p>Here are a few examples of our parser in action.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s2">&quot;1 + (2 * 3)&quot;</span>
<span class="n">peg</span> <span class="o">=</span> <span class="n">PEGParser</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
<span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">peg</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="n">mystring</span>
    <span class="n">display</span><span class="p">(</span><span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/41a8b9cbd9065249a2fdd9beedcb7feaee897ae1750dbeb3c0fc16160134284c.svg" src="_images/41a8b9cbd9065249a2fdd9beedcb7feaee897ae1750dbeb3c0fc16160134284c.svg" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s2">&quot;1 * (2 + 3.35)&quot;</span>
<span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">peg</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="n">mystring</span>
    <span class="n">display</span><span class="p">(</span><span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/2f26aaa6c2058d965a174828930b0978ae89c39cb7c02100d40b80cf654246bc.svg" src="_images/2f26aaa6c2058d965a174828930b0978ae89c39cb7c02100d40b80cf654246bc.svg" />
</div>
</div>
<p>One should be aware that while the grammar looks like a <em>CFG</em>, the language described by a <em>PEG</em> may be different. Indeed, only <em>LL(1)</em> grammars are guaranteed to represent the same language for both PEGs and other parsers. Behavior of PEGs for other classes of grammars could be surprising \cite{redziejowski2008}.</p>
</section>
</section>
<section id="parsing-context-free-grammars">
<h2>Parsing Context-Free Grammars<a class="headerlink" href="#parsing-context-free-grammars" title="Link to this heading">#</a></h2>
<section id="problems-with-peg">
<h3>Problems with PEG<a class="headerlink" href="#problems-with-peg" title="Link to this heading">#</a></h3>
<p>While <em>PEGs</em> are simple at first sight, their behavior in some cases might be a bit unintuitive. For example, here is an example \cite{redziejowski2008}:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">PEG_SURPRISE</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;&lt;A&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;a&lt;A&gt;a&quot;</span><span class="p">,</span> <span class="s2">&quot;aa&quot;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>When interpreted as a <em>CFG</em> and used as a string generator, it will produce strings of the form <code class="docutils literal notranslate"><span class="pre">aa,</span> <span class="pre">aaaa,</span> <span class="pre">aaaaaa</span></code> that is, it produces strings where the number of <code class="docutils literal notranslate"><span class="pre">a</span></code> is <span class="math notranslate nohighlight">\( 2*n \)</span> where <span class="math notranslate nohighlight">\( n &gt; 0 \)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">strings</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">GrammarFuzzer</span><span class="p">(</span><span class="n">PEG_SURPRISE</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">)</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nn</span><span class="p">):</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">expand_tree_once</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">expand_tree_with_strategy</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">expand_node_min_cost</span><span class="p">)</span>
    <span class="n">strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>
    <span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="n">strings</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;aa&#39;, &#39;aaaa&#39;, &#39;aaaaaa&#39;, &#39;aaaaaaaa&#39;]
</pre></div>
</div>
</div>
</div>
<p>However, the <em>PEG</em> parser can only recognize strings of the form <span class="math notranslate nohighlight">\(2^n\)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">peg</span> <span class="o">=</span> <span class="n">PEGParser</span><span class="p">(</span><span class="n">PEG_SURPRISE</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strings</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">ExpectError</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">peg</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>aa
aaaa
aaaaaaaa
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Traceback (most recent call last):
  File &quot;/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_10601/3226632005.py&quot;, line 4, in &lt;module&gt;
    for tree in peg.parse(s):
                ^^^^^^^^^^^^
  File &quot;/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_10601/2022555909.py&quot;, line 40, in parse
    raise SyntaxError(&quot;at &quot; + repr(text[cursor:]))
SyntaxError: at &#39;aa&#39; (expected)
</pre></div>
</div>
</div>
</div>
<p>This is not the only problem with <em>Parsing Expression Grammars</em>. While  <em>PEGs</em> are expressive and the <em>packrat</em> parser for parsing them is simple and intuitive, <em>PEGs</em> suffer from a major deficiency for our purposes. <em>PEGs</em> are oriented towards language recognition, and it is not clear how to translate an arbitrary <em>PEG</em> to a <em>CFG</em>. As we mentioned earlier, a naive re-interpretation of a <em>PEG</em> as a <em>CFG</em> does not work very well. Further, it is not clear what is the exact relation between the class of languages represented by <em>PEG</em> and the class of languages represented by <em>CFG</em>. Since our primary focus is <em>fuzzing</em> – that is <em>generation</em> of strings – , we next look at <em>parsers that can accept context-free grammars</em>.</p>
<p>The general idea of <em>CFG</em> parser is the following: Peek at the input text for the allowed number of characters, and use these, and our parser state to determine which rules can be applied to complete parsing. We next look at a typical <em>CFG</em> parsing algorithm, the Earley Parser.</p>
</section>
<section id="the-earley-parser">
<h3>The Earley Parser<a class="headerlink" href="#the-earley-parser" title="Link to this heading">#</a></h3>
<p>The Earley parser is a general parser that is able to parse any arbitrary <em>CFG</em>. It was invented by Jay Earley \cite{Earley1970} for use in computational linguistics. While its computational complexity is <span class="math notranslate nohighlight">\(O(n^3)\)</span> for parsing strings with arbitrary grammars, it can parse strings with unambiguous grammars in <span class="math notranslate nohighlight">\(O(n^2)\)</span> time, and all <em><a class="reference external" href="https://en.wikipedia.org/wiki/LR_parser">LR(k)</a></em> grammars in linear time (<span class="math notranslate nohighlight">\(O(n)\)</span> \cite{Leo1991}). Further improvements – notably handling epsilon rules – were invented by Aycock et al. \cite{Aycock2002}.</p>
<p>Note that one restriction of our implementation is that the start symbol can have only one alternative in its alternative expressions. This is not a restriction in practice because any grammar with multiple alternatives for its start symbol can be extended with a new start symbol that has the original start symbol as its only choice. That is, given a grammar as below,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">grammar</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;B&gt;&#39;</span><span class="p">],</span>
    <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>one may rewrite it as below to conform to the <em>single-alternative</em> rule.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">grammar</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;start_&gt;&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;start_&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;B&gt;&#39;</span><span class="p">],</span>
    <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Let us implement a class <code class="docutils literal notranslate"><span class="pre">EarleyParser</span></code>, again derived from <code class="docutils literal notranslate"><span class="pre">Parser</span></code> which implements an Earley parser.</p>
</section>
<section id="excursion-implementing-earleyparser">
<h3>Excursion: Implementing <code class="docutils literal notranslate"><span class="pre">EarleyParser</span></code><a class="headerlink" href="#excursion-implementing-earleyparser" title="Link to this heading">#</a></h3>
<p>We first implement a simpler parser that is a parser for nearly all <em>CFGs</em>, but not quite. In particular, our parser does not understand <em>epsilon rules</em> – rules that derive empty string. We show later how the parser can be extended to handle these.</p>
<p>We use the following grammar in our examples below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">SAMPLE_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;A&gt;&lt;B&gt;&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&lt;B&gt;c&#39;</span><span class="p">,</span> <span class="s1">&#39;a&lt;A&gt;&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;B&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;b&lt;C&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;D&gt;&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;C&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;D&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">]</span>
<span class="p">}</span>
<span class="n">C_SAMPLE_GRAMMAR</span> <span class="o">=</span> <span class="n">canonical</span><span class="p">(</span><span class="n">SAMPLE_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">syntax_diagram</span><span class="p">(</span><span class="n">SAMPLE_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>start
</pre></div>
</div>
<img alt="_images/1db53112bf2b1777ad35721d8a7efeb31a6f3ebcb8556b82d931d6923461bceb.svg" src="_images/1db53112bf2b1777ad35721d8a7efeb31a6f3ebcb8556b82d931d6923461bceb.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>A
</pre></div>
</div>
<img alt="_images/a6bb25d430ac4f67e6f087859d0756514ca2baefec562b36c5f68cb0582e255f.svg" src="_images/a6bb25d430ac4f67e6f087859d0756514ca2baefec562b36c5f68cb0582e255f.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>B
</pre></div>
</div>
<img alt="_images/789f3763c8045560d0953efe803282c0fb9ae947f93d5eb4fc88fc1b73023ebd.svg" src="_images/789f3763c8045560d0953efe803282c0fb9ae947f93d5eb4fc88fc1b73023ebd.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>C
</pre></div>
</div>
<img alt="_images/82fa940624644dcc0f5955b7c77b70d921a41c5618a71f0531eef7e485253fba.svg" src="_images/82fa940624644dcc0f5955b7c77b70d921a41c5618a71f0531eef7e485253fba.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>D
</pre></div>
</div>
<img alt="_images/800baca54e752c5325c72b12e639235076d0f3e08631f5c779c6a26e68911b35.svg" src="_images/800baca54e752c5325c72b12e639235076d0f3e08631f5c779c6a26e68911b35.svg" />
</div>
</div>
<p>The basic idea of Earley parsing is the following:</p>
<ul class="simple">
<li><p>Start with the alternative expressions corresponding to the START_SYMBOL. These represent the possible ways to parse the string from a high level. Essentially each expression represents a parsing path. Queue each expression in our set of possible parses of the string. The parsed index of an expression is the part of expression that has already been recognized. In the beginning of parse, the parsed index of all expressions is at the beginning. Further, each letter gets a queue of expressions that recognizes that letter at that point in our parse.</p></li>
<li><p>Examine our queue of possible parses and check if any of them start with a nonterminal. If it does, then that nonterminal needs to be recognized from the input before the given rule can be parsed. Hence, add the alternative expressions corresponding to the nonterminal to the queue. Do this recursively.</p></li>
<li><p>At this point, we are ready to advance. Examine the current letter in the input, and select all expressions that have that particular letter at the parsed index. These expressions can now advance one step. Advance these selected expressions by incrementing their parsed index and add them to the queue of expressions in line for recognizing the next input letter.</p></li>
<li><p>If while doing these things, we find that any of the expressions have finished parsing, we fetch its corresponding nonterminal, and advance all expressions that have that nonterminal at their parsed index.</p></li>
<li><p>Continue this procedure recursively until all expressions that we have queued for the current letter have been processed. Then start processing the queue for the next letter.</p></li>
</ul>
<p>We explain each step in detail with examples in the coming sections.</p>
<p>The parser uses dynamic programming to generate a table containing a <em>forest of possible parses</em> at each letter index – the table contains as many columns as there are letters in the input, and each column contains different parsing rules at various stages of the parse.</p>
<p>For example, given an input <code class="docutils literal notranslate"><span class="pre">adcd</span></code>, the Column 0 would contain the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;start&gt; : ● &lt;A&gt; &lt;B&gt;
</pre></div>
</div>
<p>which is the starting rule that indicates that we are currently parsing the rule <code class="docutils literal notranslate"><span class="pre">&lt;start&gt;</span></code>, and the parsing state is just before identifying the symbol <code class="docutils literal notranslate"><span class="pre">&lt;A&gt;</span></code>. It would also contain the following which are two alternative paths it could take to complete the parsing.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;A&gt; : ● a &lt;B&gt; c
&lt;A&gt; : ● a &lt;A&gt;
</pre></div>
</div>
<p>Column 1 would contain the following, which represents the possible completion after reading <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;A&gt; : a ● &lt;B&gt; c
&lt;A&gt; : a ● &lt;A&gt;
&lt;B&gt; : ● b &lt;C&gt;
&lt;B&gt; : ● &lt;D&gt;
&lt;A&gt; : ● a &lt;B&gt; c
&lt;A&gt; : ● a &lt;A&gt;
&lt;D&gt; : ● d
</pre></div>
</div>
<p>Column 2 would contain the following after reading <code class="docutils literal notranslate"><span class="pre">d</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;D&gt; : d ●
&lt;B&gt; : &lt;D&gt; ●
&lt;A&gt; : a &lt;B&gt; ● c
</pre></div>
</div>
<p>Similarly, Column 3 would contain the following after reading <code class="docutils literal notranslate"><span class="pre">c</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;A&gt; : a &lt;B&gt; c ●
&lt;start&gt; : &lt;A&gt; ● &lt;B&gt;
&lt;B&gt; : ● b &lt;C&gt;
&lt;B&gt; : ● &lt;D&gt;
&lt;D&gt; : ● d
</pre></div>
</div>
<p>Finally, Column 4 would contain the following after reading <code class="docutils literal notranslate"><span class="pre">d</span></code>, with the <code class="docutils literal notranslate"><span class="pre">●</span></code> at the end of the <code class="docutils literal notranslate"><span class="pre">&lt;start&gt;</span></code> rule indicating that the parse was successful.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;D&gt; : d ●
&lt;B&gt; : &lt;D&gt; ●
&lt;start&gt; : &lt;A&gt; &lt;B&gt; ●
</pre></div>
</div>
<p>As you can see from above, we are essentially filling a table (a table is also called a <strong>chart</strong>) of entries based on each letter we read, and the grammar rules that can be applied. This chart gives the parser its other name – Chart parsing.</p>
<section id="columns">
<h4>Columns<a class="headerlink" href="#columns" title="Link to this heading">#</a></h4>
<p>We define the <code class="docutils literal notranslate"><span class="pre">Column</span></code> first. The <code class="docutils literal notranslate"><span class="pre">Column</span></code> is initialized by its own <code class="docutils literal notranslate"><span class="pre">index</span></code> in the input string, and the <code class="docutils literal notranslate"><span class="pre">letter</span></code> at that index. Internally, we also keep track of the states that are added to the column as the parsing progresses.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Column</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">letter</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">letter</span> <span class="o">=</span> <span class="n">index</span><span class="p">,</span> <span class="n">letter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unique</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> chart[</span><span class="si">%d</span><span class="s2">]</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">letter</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">finished</span><span class="p">()))</span>
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Column</span></code> only stores unique <code class="docutils literal notranslate"><span class="pre">states</span></code>. Hence, when a new <code class="docutils literal notranslate"><span class="pre">state</span></code> is <code class="docutils literal notranslate"><span class="pre">added</span></code> to our <code class="docutils literal notranslate"><span class="pre">Column</span></code>, we check whether it is already known.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Column</span><span class="p">(</span><span class="n">Column</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unique</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unique</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unique</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="n">state</span><span class="o">.</span><span class="n">e_col</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unique</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="items">
<h4>Items<a class="headerlink" href="#items" title="Link to this heading">#</a></h4>
<p>An item represents a <em>parse in progress for a specific rule.</em> Hence the item contains the name of the nonterminal, and the corresponding alternative expression (<code class="docutils literal notranslate"><span class="pre">expr</span></code>) which together form the rule, and the current position of parsing in this expression – <code class="docutils literal notranslate"><span class="pre">dot</span></code>.</p>
<p><strong>Note.</strong> If you are familiar with <a class="reference external" href="https://en.wikipedia.org/wiki/LR_parser">LR parsing</a>, you will notice that an item is simply an <code class="docutils literal notranslate"><span class="pre">LR0</span></code> item.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Item</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">dot</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dot</span> <span class="o">=</span> <span class="n">name</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">dot</span>
</pre></div>
</div>
</div>
</div>
<p>We also provide a few convenience methods. The method <code class="docutils literal notranslate"><span class="pre">finished()</span></code> checks if the <code class="docutils literal notranslate"><span class="pre">dot</span></code> has moved beyond the last element in <code class="docutils literal notranslate"><span class="pre">expr</span></code>. The method <code class="docutils literal notranslate"><span class="pre">advance()</span></code> produces a new <code class="docutils literal notranslate"><span class="pre">Item</span></code> with the <code class="docutils literal notranslate"><span class="pre">dot</span></code> advanced one token, and represents an advance of the parsing.  The method <code class="docutils literal notranslate"><span class="pre">at_dot()</span></code> returns the current symbol being parsed.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Item</span><span class="p">(</span><span class="n">Item</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">finished</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dot</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">advance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Item</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">at_dot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dot</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dot</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
</pre></div>
</div>
</div>
</div>
<p>Here is how an item could be used. We first define our item</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">item_name</span> <span class="o">=</span> <span class="s1">&#39;&lt;B&gt;&#39;</span>
<span class="n">item_expr</span> <span class="o">=</span> <span class="n">C_SAMPLE_GRAMMAR</span><span class="p">[</span><span class="n">item_name</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
<span class="n">an_item</span> <span class="o">=</span> <span class="n">Item</span><span class="p">(</span><span class="n">item_name</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">item_expr</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>To determine where the status of parsing, we use <code class="docutils literal notranslate"><span class="pre">at_dot()</span></code></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">an_item</span><span class="o">.</span><span class="n">at_dot</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;&lt;D&gt;&#39;
</pre></div>
</div>
</div>
</div>
<p>That is, the next symbol to be parsed is <code class="docutils literal notranslate"><span class="pre">&lt;D&gt;</span></code></p>
<p>If we advance the item, we get another item that represents the finished parsing rule <code class="docutils literal notranslate"><span class="pre">&lt;B&gt;</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">another_item</span> <span class="o">=</span> <span class="n">an_item</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">another_item</span><span class="o">.</span><span class="n">finished</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
</section>
<section id="states">
<h4>States<a class="headerlink" href="#states" title="Link to this heading">#</a></h4>
<p>For <code class="docutils literal notranslate"><span class="pre">Earley</span></code> parsing, the state of the parsing is simply one <code class="docutils literal notranslate"><span class="pre">Item</span></code> along with some meta information such as the starting <code class="docutils literal notranslate"><span class="pre">s_col</span></code>  and ending column <code class="docutils literal notranslate"><span class="pre">e_col</span></code> for each state. Hence we inherit from <code class="docutils literal notranslate"><span class="pre">Item</span></code> to create a <code class="docutils literal notranslate"><span class="pre">State</span></code>.
Since we are interested in comparing states, we define <code class="docutils literal notranslate"><span class="pre">hash()</span></code> and <code class="docutils literal notranslate"><span class="pre">eq()</span></code> with the corresponding methods.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">State</span><span class="p">(</span><span class="n">Item</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">dot</span><span class="p">,</span> <span class="n">s_col</span><span class="p">,</span> <span class="n">e_col</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">dot</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">e_col</span> <span class="o">=</span> <span class="n">s_col</span><span class="p">,</span> <span class="n">e_col</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">idx</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">var</span><span class="o">.</span><span class="n">index</span> <span class="k">if</span> <span class="n">var</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;:= &#39;</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="p">[</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">dot</span><span class="p">],</span> <span class="s1">&#39;|&#39;</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dot</span><span class="p">:]]</span>
        <span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;(</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">idx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_col</span><span class="p">),</span> <span class="n">idx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">e_col</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">State</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">e_col</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_t</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_col</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_t</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">advance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">State</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_col</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The usage of <code class="docutils literal notranslate"><span class="pre">State</span></code> is similar to that of <code class="docutils literal notranslate"><span class="pre">Item</span></code>. The only difference is that it is used along with the <code class="docutils literal notranslate"><span class="pre">Column</span></code> to track the parsing state. For example, we initialize the first column as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">col_0</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="n">item_tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="o">*</span><span class="n">C_SAMPLE_GRAMMAR</span><span class="p">[</span><span class="n">START_SYMBOL</span><span class="p">])</span>
<span class="n">start_state</span> <span class="o">=</span> <span class="n">State</span><span class="p">(</span><span class="n">START_SYMBOL</span><span class="p">,</span> <span class="n">item_tuple</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">col_0</span><span class="p">)</span>
<span class="n">col_0</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">start_state</span><span class="p">)</span>
<span class="n">start_state</span><span class="o">.</span><span class="n">at_dot</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;&lt;A&gt;&#39;
</pre></div>
</div>
</div>
</div>
<p>The first column is then updated by using <code class="docutils literal notranslate"><span class="pre">add()</span></code> method of <code class="docutils literal notranslate"><span class="pre">Column</span></code></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sym</span> <span class="o">=</span> <span class="n">start_state</span><span class="o">.</span><span class="n">at_dot</span><span class="p">()</span>
<span class="k">for</span> <span class="n">alt</span> <span class="ow">in</span> <span class="n">C_SAMPLE_GRAMMAR</span><span class="p">[</span><span class="n">sym</span><span class="p">]:</span>
    <span class="n">col_0</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">State</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">alt</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">col_0</span><span class="p">))</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">col_0</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;start&gt;:= | &lt;A&gt; &lt;B&gt;(0,0)
&lt;A&gt;:= | a &lt;B&gt; c(0,0)
&lt;A&gt;:= | a &lt;A&gt;(0,0)
</pre></div>
</div>
</div>
</div>
</section>
<section id="the-parsing-algorithm">
<h4>The Parsing Algorithm<a class="headerlink" href="#the-parsing-algorithm" title="Link to this heading">#</a></h4>
<p>The <em>Earley</em> algorithm starts by initializing the chart with columns (as many as there are letters in the input). We also seed the first column with a state representing the expression corresponding to the start symbol. In our case, the state corresponds to the start symbol with the <code class="docutils literal notranslate"><span class="pre">dot</span></code> at <code class="docutils literal notranslate"><span class="pre">0</span></code> is represented as below. The <code class="docutils literal notranslate"><span class="pre">●</span></code> symbol represents the parsing status. In this case, we have not parsed anything.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;start&gt;: ● &lt;A&gt; &lt;B&gt;
</pre></div>
</div>
<p>We pass this partial chart to a method for filling the rest of the parse chart.</p>
<p>Before starting to parse, we seed the chart with the state representing the ongoing parse of the start symbol.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EarleyParser</span><span class="p">(</span><span class="n">Parser</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Earley Parser. This parser can parse any context-free grammar.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chart</span><span class="p">:</span> <span class="n">List</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># for type checking</span>

    <span class="k">def</span> <span class="nf">chart_parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
        <span class="n">alt</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cgrammar</span><span class="p">[</span><span class="n">start</span><span class="p">])</span>
        <span class="n">chart</span> <span class="o">=</span> <span class="p">[</span><span class="n">Column</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">tok</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tok</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">words</span><span class="p">])]</span>
        <span class="n">chart</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">State</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">alt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">chart</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_chart</span><span class="p">(</span><span class="n">chart</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The main parsing loop in <code class="docutils literal notranslate"><span class="pre">fill_chart()</span></code> has three fundamental operations. <code class="docutils literal notranslate"><span class="pre">predict()</span></code>, <code class="docutils literal notranslate"><span class="pre">scan()</span></code>, and <code class="docutils literal notranslate"><span class="pre">complete()</span></code>. We discuss <code class="docutils literal notranslate"><span class="pre">predict</span></code> next.</p>
</section>
<section id="predicting-states">
<h4>Predicting States<a class="headerlink" href="#predicting-states" title="Link to this heading">#</a></h4>
<p>We have already seeded <code class="docutils literal notranslate"><span class="pre">chart[0]</span></code> with a state <code class="docutils literal notranslate"><span class="pre">[&lt;A&gt;,&lt;B&gt;]</span></code> with <code class="docutils literal notranslate"><span class="pre">dot</span></code> at <code class="docutils literal notranslate"><span class="pre">0</span></code>. Next, given that <code class="docutils literal notranslate"><span class="pre">&lt;A&gt;</span></code> is a nonterminal, we <code class="docutils literal notranslate"><span class="pre">predict</span></code> the possible parse continuations of this state. That is, it could be either <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;B&gt;</span> <span class="pre">c</span></code> or <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&lt;A&gt;</span></code>.</p>
<p>The general idea of <code class="docutils literal notranslate"><span class="pre">predict()</span></code> is as follows: Say you have a state with name <code class="docutils literal notranslate"><span class="pre">&lt;A&gt;</span></code> from the above grammar, and expression containing <code class="docutils literal notranslate"><span class="pre">[a,&lt;B&gt;,c]</span></code>. Imagine that you have seen <code class="docutils literal notranslate"><span class="pre">a</span></code> already, which means that the <code class="docutils literal notranslate"><span class="pre">dot</span></code> will be on <code class="docutils literal notranslate"><span class="pre">&lt;B&gt;</span></code>. Below, is a representation of our parse status. The left-hand side of ● represents the portion already parsed (<code class="docutils literal notranslate"><span class="pre">a</span></code>), and the right-hand side represents the portion yet to be parsed (<code class="docutils literal notranslate"><span class="pre">&lt;B&gt;</span> <span class="pre">c</span></code>).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;A&gt;: a  ●  &lt;B&gt; c
</pre></div>
</div>
<p>To recognize <code class="docutils literal notranslate"><span class="pre">&lt;B&gt;</span></code>, we look at the definition of <code class="docutils literal notranslate"><span class="pre">&lt;B&gt;</span></code>, which has different alternative expressions. The <code class="docutils literal notranslate"><span class="pre">predict()</span></code> step adds each of these alternatives to the set of states, with <code class="docutils literal notranslate"><span class="pre">dot</span></code> at <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;A&gt;: a ● &lt;B&gt; c
&lt;B&gt;: ● b c
&lt;B&gt;: ● &lt;D&gt;
</pre></div>
</div>
<p>In essence, the <code class="docutils literal notranslate"><span class="pre">predict()</span></code> method, when called with the current nonterminal, fetches the alternative expressions corresponding to this nonterminal, and adds these as predicted <em>child</em> states to the <em>current</em> column.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EarleyParser</span><span class="p">(</span><span class="n">EarleyParser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">alt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cgrammar</span><span class="p">[</span><span class="n">sym</span><span class="p">]:</span>
            <span class="n">col</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">State</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">alt</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>To see how to use <code class="docutils literal notranslate"><span class="pre">predict</span></code>, we first construct the 0th column as before, and we assign the constructed column to an instance of the EarleyParser.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">col_0</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="n">col_0</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">start_state</span><span class="p">)</span>
<span class="n">ep</span> <span class="o">=</span> <span class="n">EarleyParser</span><span class="p">(</span><span class="n">SAMPLE_GRAMMAR</span><span class="p">)</span>
<span class="n">ep</span><span class="o">.</span><span class="n">chart</span> <span class="o">=</span> <span class="p">[</span><span class="n">col_0</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>It should contain a single state – <code class="docutils literal notranslate"><span class="pre">&lt;start&gt;</span> <span class="pre">at</span> <span class="pre">0</span></code></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ep</span><span class="o">.</span><span class="n">chart</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;start&gt;:= | &lt;A&gt; &lt;B&gt;(0,0)
</pre></div>
</div>
</div>
</div>
<p>We apply <code class="docutils literal notranslate"><span class="pre">predict()</span></code> to fill out the 0th column, and the column should contain the possible parse paths.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ep</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">col_0</span><span class="p">,</span> <span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ep</span><span class="o">.</span><span class="n">chart</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;start&gt;:= | &lt;A&gt; &lt;B&gt;(0,0)
&lt;A&gt;:= | a &lt;B&gt; c(0,0)
&lt;A&gt;:= | a &lt;A&gt;(0,0)
</pre></div>
</div>
</div>
</div>
</section>
<section id="scanning-tokens">
<h4>Scanning Tokens<a class="headerlink" href="#scanning-tokens" title="Link to this heading">#</a></h4>
<p>What if rather than a nonterminal, the state contained a terminal symbol such as a letter? In that case, we are ready to make some progress. For example, consider the second state:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;B&gt;: ● b c
</pre></div>
</div>
<p>We <code class="docutils literal notranslate"><span class="pre">scan</span></code> the next column’s letter. Say the next token is <code class="docutils literal notranslate"><span class="pre">b</span></code>.
If the letter matches what we have, then create a new state by advancing the current state by one letter.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;B&gt;: b ● c
</pre></div>
</div>
<p>This new state is added to the next column (i.e the column that has the matched letter).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EarleyParser</span><span class="p">(</span><span class="n">EarleyParser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">scan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">letter</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">letter</span> <span class="o">==</span> <span class="n">col</span><span class="o">.</span><span class="n">letter</span><span class="p">:</span>
            <span class="n">col</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">advance</span><span class="p">())</span>
</pre></div>
</div>
</div>
</div>
<p>As before, we construct the partial parse first, this time adding a new column so that we can observe the effects of <code class="docutils literal notranslate"><span class="pre">scan()</span></code></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ep</span> <span class="o">=</span> <span class="n">EarleyParser</span><span class="p">(</span><span class="n">SAMPLE_GRAMMAR</span><span class="p">)</span>
<span class="n">col_1</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="n">ep</span><span class="o">.</span><span class="n">chart</span> <span class="o">=</span> <span class="p">[</span><span class="n">col_0</span><span class="p">,</span> <span class="n">col_1</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">new_state</span> <span class="o">=</span> <span class="n">ep</span><span class="o">.</span><span class="n">chart</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">new_state</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;A&gt;:= | a &lt;B&gt; c(0,0)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ep</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="n">col_1</span><span class="p">,</span> <span class="n">new_state</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ep</span><span class="o">.</span><span class="n">chart</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;A&gt;:= a | &lt;B&gt; c(0,1)
</pre></div>
</div>
</div>
</div>
</section>
<section id="completing-processing">
<h4>Completing Processing<a class="headerlink" href="#completing-processing" title="Link to this heading">#</a></h4>
<p>When we advance, what if we actually <code class="docutils literal notranslate"><span class="pre">complete()</span></code> the processing of the current rule? If so, we want to update not just this state, but also all the <em>parent</em> states from which this state was derived.
For example, say we have states as below.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;A&gt;: a ● &lt;B&gt; c
&lt;B&gt;: b c ● 
</pre></div>
</div>
<p>The state <code class="docutils literal notranslate"><span class="pre">&lt;B&gt;:</span> <span class="pre">b</span> <span class="pre">c</span> <span class="pre">●</span></code> is now complete. So, we need to advance <code class="docutils literal notranslate"><span class="pre">&lt;A&gt;:</span> <span class="pre">a</span> <span class="pre">●</span> <span class="pre">&lt;B&gt;</span> <span class="pre">c</span></code> one step forward.</p>
<p>How do we determine the parent states? Note from <code class="docutils literal notranslate"><span class="pre">predict</span></code> that we added the predicted child states to the <em>same</em> column as that of the inspected state. Hence, we look at the starting column of the current state, with the same symbol <code class="docutils literal notranslate"><span class="pre">at_dot</span></code> as that of the name of the completed state.</p>
<p>For each such parent found, we advance that parent (because we have just finished parsing that nonterminal for their <code class="docutils literal notranslate"><span class="pre">at_dot</span></code>) and add the new states to the current column.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EarleyParser</span><span class="p">(</span><span class="n">EarleyParser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">complete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">earley_complete</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">earley_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">parent_states</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">st</span> <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">s_col</span><span class="o">.</span><span class="n">states</span> <span class="k">if</span> <span class="n">st</span><span class="o">.</span><span class="n">at_dot</span><span class="p">()</span> <span class="o">==</span> <span class="n">state</span><span class="o">.</span><span class="n">name</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">parent_states</span><span class="p">:</span>
            <span class="n">col</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">advance</span><span class="p">())</span>
</pre></div>
</div>
</div>
</div>
<p>Here is an example of completed processing. First we complete the Column 0</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ep</span> <span class="o">=</span> <span class="n">EarleyParser</span><span class="p">(</span><span class="n">SAMPLE_GRAMMAR</span><span class="p">)</span>
<span class="n">col_1</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="n">col_2</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
<span class="n">ep</span><span class="o">.</span><span class="n">chart</span> <span class="o">=</span> <span class="p">[</span><span class="n">col_0</span><span class="p">,</span> <span class="n">col_1</span><span class="p">,</span> <span class="n">col_2</span><span class="p">]</span>
<span class="n">ep</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">col_0</span><span class="p">,</span> <span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ep</span><span class="o">.</span><span class="n">chart</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;start&gt;:= | &lt;A&gt; &lt;B&gt;(0,0)
&lt;A&gt;:= | a &lt;B&gt; c(0,0)
&lt;A&gt;:= | a &lt;A&gt;(0,0)
</pre></div>
</div>
</div>
</div>
<p>Then we use <code class="docutils literal notranslate"><span class="pre">scan()</span></code> to populate Column 1</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">ep</span><span class="o">.</span><span class="n">chart</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">at_dot</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">SAMPLE_GRAMMAR</span><span class="p">:</span>
        <span class="n">ep</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="n">col_1</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ep</span><span class="o">.</span><span class="n">chart</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;A&gt;:= a | &lt;B&gt; c(0,1)
&lt;A&gt;:= a | &lt;A&gt;(0,1)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">ep</span><span class="o">.</span><span class="n">chart</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">at_dot</span><span class="p">()</span> <span class="ow">in</span> <span class="n">SAMPLE_GRAMMAR</span><span class="p">:</span>
        <span class="n">ep</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">col_1</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">at_dot</span><span class="p">(),</span> <span class="n">state</span><span class="p">)</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ep</span><span class="o">.</span><span class="n">chart</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;A&gt;:= a | &lt;B&gt; c(0,1)
&lt;A&gt;:= a | &lt;A&gt;(0,1)
&lt;B&gt;:= | b &lt;C&gt;(1,1)
&lt;B&gt;:= | &lt;D&gt;(1,1)
&lt;A&gt;:= | a &lt;B&gt; c(1,1)
&lt;A&gt;:= | a &lt;A&gt;(1,1)
&lt;D&gt;:= | d(1,1)
</pre></div>
</div>
</div>
</div>
<p>Then we use <code class="docutils literal notranslate"><span class="pre">scan()</span></code> again to populate Column 2</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">ep</span><span class="o">.</span><span class="n">chart</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">at_dot</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">SAMPLE_GRAMMAR</span><span class="p">:</span>
        <span class="n">ep</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="n">col_2</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">at_dot</span><span class="p">())</span>

<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ep</span><span class="o">.</span><span class="n">chart</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;D&gt;:= d |(1,2)
</pre></div>
</div>
</div>
</div>
<p>Now, we can use <code class="docutils literal notranslate"><span class="pre">complete()</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">ep</span><span class="o">.</span><span class="n">chart</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">finished</span><span class="p">():</span>
        <span class="n">ep</span><span class="o">.</span><span class="n">complete</span><span class="p">(</span><span class="n">col_2</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ep</span><span class="o">.</span><span class="n">chart</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;D&gt;:= d |(1,2)
&lt;B&gt;:= &lt;D&gt; |(1,2)
&lt;A&gt;:= a &lt;B&gt; | c(0,2)
</pre></div>
</div>
</div>
</div>
</section>
<section id="filling-the-chart">
<h4>Filling the Chart<a class="headerlink" href="#filling-the-chart" title="Link to this heading">#</a></h4>
<p>The main driving loop in <code class="docutils literal notranslate"><span class="pre">fill_chart()</span></code> essentially calls these operations in order. We loop over each column in order.</p>
<ul class="simple">
<li><p>For each column, fetch one state in the column at a time, and check if the state is <code class="docutils literal notranslate"><span class="pre">finished</span></code>.</p>
<ul>
<li><p>If it is, then we <code class="docutils literal notranslate"><span class="pre">complete()</span></code> all the parent states depending on this state.</p></li>
</ul>
</li>
<li><p>If the state was not finished, we check to see if the state’s current symbol <code class="docutils literal notranslate"><span class="pre">at_dot</span></code> is a nonterminal.</p>
<ul>
<li><p>If it is a nonterminal, we <code class="docutils literal notranslate"><span class="pre">predict()</span></code> possible continuations, and update the current column with these states.</p></li>
<li><p>If it was not, we <code class="docutils literal notranslate"><span class="pre">scan()</span></code> the next column and advance the current state if it matches the next letter.</p></li>
</ul>
</li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EarleyParser</span><span class="p">(</span><span class="n">EarleyParser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">fill_chart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chart</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">col</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">finished</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">complete</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sym</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">at_dot</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cgrammar</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chart</span><span class="p">):</span>
                            <span class="k">continue</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="n">chart</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">state</span><span class="p">,</span> <span class="n">sym</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">chart</span>
</pre></div>
</div>
</div>
</div>
<p>We now can recognize a given string as belonging to a language represented by a grammar.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ep</span> <span class="o">=</span> <span class="n">EarleyParser</span><span class="p">(</span><span class="n">SAMPLE_GRAMMAR</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">columns</span> <span class="o">=</span> <span class="n">ep</span><span class="o">.</span><span class="n">chart_parse</span><span class="p">(</span><span class="s1">&#39;adcd&#39;</span><span class="p">,</span> <span class="n">START_SYMBOL</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>None chart[0]
 

a chart[1]
 

d chart[2]
&lt;D&gt;:= d |(1,2)
&lt;B&gt;:= &lt;D&gt; |(1,2) 

c chart[3]
&lt;A&gt;:= a &lt;B&gt; c |(0,3) 

d chart[4]
&lt;D&gt;:= d |(3,4)
&lt;B&gt;:= &lt;D&gt; |(3,4)
&lt;start&gt;:= &lt;A&gt; &lt;B&gt; |(0,4) 
</pre></div>
</div>
</div>
</div>
<p>The chart we printed above only shows completed entries at each index. The parenthesized expression indicates the column just before the first character was recognized, and the ending column.</p>
<p>Notice how the <code class="docutils literal notranslate"><span class="pre">&lt;start&gt;</span></code> nonterminal shows fully parsed status.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">last_col</span> <span class="o">=</span> <span class="n">columns</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">last_col</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;start&gt;:= &lt;A&gt; &lt;B&gt; |(0,4)
</pre></div>
</div>
</div>
</div>
<p>Since <code class="docutils literal notranslate"><span class="pre">chart_parse()</span></code> returns the completed table, we now need to extract the derivation trees.</p>
</section>
<section id="the-parse-method">
<h4>The Parse Method<a class="headerlink" href="#the-parse-method" title="Link to this heading">#</a></h4>
<p>For determining how far we have managed to parse, we simply look for the last index from <code class="docutils literal notranslate"><span class="pre">chart_parse()</span></code> where the <code class="docutils literal notranslate"><span class="pre">start_symbol</span></code> was found.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EarleyParser</span><span class="p">(</span><span class="n">EarleyParser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">parse_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chart_parse</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_symbol</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">):</span>
            <span class="n">states</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">st</span> <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">col</span><span class="o">.</span><span class="n">states</span> <span class="k">if</span> <span class="n">st</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_symbol</span><span class="p">()</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="n">states</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">col</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">states</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">[]</span>
</pre></div>
</div>
</div>
</div>
<p>Here is the <code class="docutils literal notranslate"><span class="pre">parse_prefix()</span></code> in action.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ep</span> <span class="o">=</span> <span class="n">EarleyParser</span><span class="p">(</span><span class="n">SAMPLE_GRAMMAR</span><span class="p">)</span>
<span class="n">cursor</span><span class="p">,</span> <span class="n">last_states</span> <span class="o">=</span> <span class="n">ep</span><span class="o">.</span><span class="n">parse_prefix</span><span class="p">(</span><span class="s1">&#39;adcd&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">last_states</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4 [&#39;&lt;start&gt;:= &lt;A&gt; &lt;B&gt; |(0,4)&#39;]
</pre></div>
</div>
</div>
</div>
<p>The following is adapted from the excellent reference on Earley parsing by <a class="reference external" href="http://loup-vaillant.fr/tutorials/earley-parsing/">Loup Vaillant</a>.</p>
<p>Our <code class="docutils literal notranslate"><span class="pre">parse()</span></code> method is as follows. It depends on two methods <code class="docutils literal notranslate"><span class="pre">parse_forest()</span></code> and <code class="docutils literal notranslate"><span class="pre">extract_trees()</span></code> that will be defined next.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EarleyParser</span><span class="p">(</span><span class="n">EarleyParser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="n">cursor</span><span class="p">,</span> <span class="n">states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_prefix</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">states</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">finished</span><span class="p">()),</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cursor</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">start</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s2">&quot;at &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">cursor</span><span class="p">:]))</span>

        <span class="n">forest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_forest</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_trees</span><span class="p">(</span><span class="n">forest</span><span class="p">):</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">prune_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="parsing-paths">
<h4>Parsing Paths<a class="headerlink" href="#parsing-paths" title="Link to this heading">#</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">parse_paths()</span></code> method tries to unify the given expression in <code class="docutils literal notranslate"><span class="pre">named_expr</span></code> with the parsed string. For that, it extracts the last symbol in <code class="docutils literal notranslate"><span class="pre">named_expr</span></code> and checks if it is a terminal symbol. If it is, then it checks the chart at <code class="docutils literal notranslate"><span class="pre">til</span></code> to see if the letter corresponding to the position matches the terminal symbol. If it does, extend our start index by the length of the symbol.</p>
<p>If the symbol was a nonterminal symbol, then we retrieve the parsed states at the current end column index (<code class="docutils literal notranslate"><span class="pre">til</span></code>) that correspond to the nonterminal symbol, and collect the start index. These are the end column indexes for the remaining expression.</p>
<p>Given our list of start indexes, we obtain the parse paths from the remaining expression. If we can obtain any, then we return the parse paths. If not, we return an empty list.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EarleyParser</span><span class="p">(</span><span class="n">EarleyParser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">parse_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">named_expr</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">frm</span><span class="p">,</span> <span class="n">til</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">paths</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[[(</span><span class="n">state</span><span class="p">,</span> <span class="n">k</span><span class="p">)]]</span> <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">frm</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[[(</span><span class="n">state</span><span class="p">,</span> <span class="n">k</span><span class="p">)]</span> <span class="o">+</span> <span class="n">r</span>
                        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_paths</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">frm</span><span class="p">,</span> <span class="n">start</span><span class="p">)]</span>

        <span class="o">*</span><span class="n">expr</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="n">named_expr</span>
        <span class="n">starts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cgrammar</span><span class="p">:</span>
            <span class="n">starts</span> <span class="o">=</span> <span class="p">([(</span><span class="n">var</span><span class="p">,</span> <span class="n">til</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="p">),</span>
                        <span class="s1">&#39;t&#39;</span><span class="p">)]</span> <span class="k">if</span> <span class="n">til</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">chart</span><span class="p">[</span><span class="n">til</span><span class="p">]</span><span class="o">.</span><span class="n">letter</span> <span class="o">==</span> <span class="n">var</span> <span class="k">else</span> <span class="p">[])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">starts</span> <span class="o">=</span> <span class="p">[(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">s_col</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">chart</span><span class="p">[</span><span class="n">til</span><span class="p">]</span><span class="o">.</span><span class="n">states</span>
                      <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">finished</span><span class="p">()</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">var</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">starts</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">expr</span><span class="p">)]</span>
</pre></div>
</div>
</div>
</div>
<p>Here is the <code class="docutils literal notranslate"><span class="pre">parse_paths()</span></code> in action</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">SAMPLE_GRAMMAR</span><span class="p">[</span><span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">])</span>
<span class="n">ep</span> <span class="o">=</span> <span class="n">EarleyParser</span><span class="p">(</span><span class="n">SAMPLE_GRAMMAR</span><span class="p">)</span>
<span class="n">completed_start</span> <span class="o">=</span> <span class="n">last_states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">paths</span> <span class="o">=</span> <span class="n">ep</span><span class="o">.</span><span class="n">parse_paths</span><span class="p">(</span><span class="n">completed_start</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">s_</span><span class="p">)</span> <span class="k">for</span> <span class="n">s_</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;&lt;A&gt;&lt;B&gt;&#39;]
[[&#39;&lt;B&gt;:= &lt;D&gt; |(3,4)&#39;, &#39;n&#39;], [&#39;&lt;A&gt;:= a &lt;B&gt; c |(0,3)&#39;, &#39;n&#39;]]
</pre></div>
</div>
</div>
</div>
<p>That is, the parse path for <code class="docutils literal notranslate"><span class="pre">&lt;start&gt;</span></code> given the input <code class="docutils literal notranslate"><span class="pre">adcd</span></code> included recognizing the expression <code class="docutils literal notranslate"><span class="pre">&lt;A&gt;&lt;B&gt;</span></code>. This was recognized by the two states: <code class="docutils literal notranslate"><span class="pre">&lt;A&gt;</span></code> from input(0) to input(2) which further involved recognizing the rule <code class="docutils literal notranslate"><span class="pre">a&lt;B&gt;c</span></code>, and the next state <code class="docutils literal notranslate"><span class="pre">&lt;B&gt;</span></code> from input(3) which involved recognizing the rule <code class="docutils literal notranslate"><span class="pre">&lt;D&gt;</span></code>.</p>
</section>
<section id="parsing-forests">
<h4>Parsing Forests<a class="headerlink" href="#parsing-forests" title="Link to this heading">#</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">parse_forest()</span></code> method takes the state which represents the completed parse, and determines the possible ways that its expressions corresponded to the parsed expression. For example, say we are parsing <code class="docutils literal notranslate"><span class="pre">1+2+3</span></code>, and the state has <code class="docutils literal notranslate"><span class="pre">[&lt;expr&gt;,+,&lt;expr&gt;]</span></code> in <code class="docutils literal notranslate"><span class="pre">expr</span></code>. It could have been parsed as either <code class="docutils literal notranslate"><span class="pre">[{&lt;expr&gt;:1+2},+,{&lt;expr&gt;:3}]</span></code> or <code class="docutils literal notranslate"><span class="pre">[{&lt;expr&gt;:1},+,{&lt;expr&gt;:2+3}]</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EarleyParser</span><span class="p">(</span><span class="n">EarleyParser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">forest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">chart</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_forest</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span> <span class="k">else</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">[])</span>

    <span class="k">def</span> <span class="nf">parse_forest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">pathexprs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_paths</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">s_col</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                                     <span class="n">state</span><span class="o">.</span><span class="n">e_col</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">expr</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">state</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="p">[[(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">chart</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">pathexpr</span><span class="p">)]</span>
                            <span class="k">for</span> <span class="n">pathexpr</span> <span class="ow">in</span> <span class="n">pathexprs</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ep</span> <span class="o">=</span> <span class="n">EarleyParser</span><span class="p">(</span><span class="n">SAMPLE_GRAMMAR</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">ep</span><span class="o">.</span><span class="n">parse_forest</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">last_states</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">result</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(&#39;&lt;start&gt;&#39;,
 [[(&lt;__main__.State at 0x1071c37d0&gt;,
    &#39;n&#39;,
    [&lt;__main__.Column at 0x1071c2810&gt;,
     &lt;__main__.Column at 0x1071c27e0&gt;,
     &lt;__main__.Column at 0x1071c29f0&gt;,
     &lt;__main__.Column at 0x1071c1be0&gt;,
     &lt;__main__.Column at 0x1071c30e0&gt;]),
   (&lt;__main__.State at 0x1071c3980&gt;,
    &#39;n&#39;,
    [&lt;__main__.Column at 0x1071c2810&gt;,
     &lt;__main__.Column at 0x1071c27e0&gt;,
     &lt;__main__.Column at 0x1071c29f0&gt;,
     &lt;__main__.Column at 0x1071c1be0&gt;,
     &lt;__main__.Column at 0x1071c30e0&gt;])]])
</pre></div>
</div>
</div>
</div>
</section>
<section id="extracting-trees">
<h4>Extracting Trees<a class="headerlink" href="#extracting-trees" title="Link to this heading">#</a></h4>
<p>What we have from <code class="docutils literal notranslate"><span class="pre">parse_forest()</span></code> is a forest of trees. We need to extract a single tree from that forest. That is accomplished as follows.</p>
<p>(For now, we return the first available derivation tree. To do that, we need to extract the parse forest from the state corresponding to <code class="docutils literal notranslate"><span class="pre">start</span></code>.)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EarleyParser</span><span class="p">(</span><span class="n">EarleyParser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">extract_a_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forest_node</span><span class="p">):</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">paths</span> <span class="o">=</span> <span class="n">forest_node</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">paths</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">extract_a_tree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forest</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">))</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

    <span class="k">def</span> <span class="nf">extract_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forest</span><span class="p">):</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_a_tree</span><span class="p">(</span><span class="n">forest</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We now verify that our parser can parse a given expression.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A3_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;&lt;start&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;bexpr&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;bexpr&gt;&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;&lt;aexpr&gt;&lt;gt&gt;&lt;aexpr&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;aexpr&gt;&lt;lt&gt;&lt;aexpr&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;aexpr&gt;=&lt;aexpr&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;&lt;bexpr&gt;=&lt;bexpr&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;bexpr&gt;&amp;&lt;bexpr&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;bexpr&gt;|&lt;bexpr&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;(&lt;bexrp&gt;)&quot;</span>
    <span class="p">],</span>
    <span class="s2">&quot;&lt;aexpr&gt;&quot;</span><span class="p">:</span>
    <span class="p">[</span><span class="s2">&quot;&lt;aexpr&gt;+&lt;aexpr&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;aexpr&gt;-&lt;aexpr&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;(&lt;aexpr&gt;)&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;integer&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;integer&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;digit&gt;&lt;integer&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;digit&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;digit&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">,</span> <span class="s2">&quot;4&quot;</span><span class="p">,</span> <span class="s2">&quot;5&quot;</span><span class="p">,</span> <span class="s2">&quot;6&quot;</span><span class="p">,</span> <span class="s2">&quot;7&quot;</span><span class="p">,</span> <span class="s2">&quot;8&quot;</span><span class="p">,</span> <span class="s2">&quot;9&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;lt&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;&#39;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;gt&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&gt;&#39;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">syntax_diagram</span><span class="p">(</span><span class="n">A3_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>start
</pre></div>
</div>
<img alt="_images/fb2d812d4ef8e0de58a0011128cbadcadee84b9997b262aa21a60e2c0df6a533.svg" src="_images/fb2d812d4ef8e0de58a0011128cbadcadee84b9997b262aa21a60e2c0df6a533.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>bexpr
</pre></div>
</div>
<img alt="_images/004f643d0250563d8f097dded86e64ba102d4e71ebbf224237a73f79f927430c.svg" src="_images/004f643d0250563d8f097dded86e64ba102d4e71ebbf224237a73f79f927430c.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>aexpr
</pre></div>
</div>
<img alt="_images/9cc79b6d220333d5771aed346d7f90582357f4a3ada68569244b70b31c23ecdb.svg" src="_images/9cc79b6d220333d5771aed346d7f90582357f4a3ada68569244b70b31c23ecdb.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>integer
</pre></div>
</div>
<img alt="_images/5a75993e5ed69c1b52c21d919b3e1c6d999e993369f42728385683101967b614.svg" src="_images/5a75993e5ed69c1b52c21d919b3e1c6d999e993369f42728385683101967b614.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>digit
</pre></div>
</div>
<img alt="_images/831527e2b2231b00574fb7a68ba1dce71a738444df89dc5f1c870b2354eef828.svg" src="_images/831527e2b2231b00574fb7a68ba1dce71a738444df89dc5f1c870b2354eef828.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>lt
</pre></div>
</div>
<img alt="_images/5fca9541bdda2f0a623c8880887a0f168a4e8f793499d04b80f2e267704fed80.svg" src="_images/5fca9541bdda2f0a623c8880887a0f168a4e8f793499d04b80f2e267704fed80.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>gt
</pre></div>
</div>
<img alt="_images/2570c2b2f3687fe1216b522fdfe85367f5fed4787a93b83b06797ee14c943b4d.svg" src="_images/2570c2b2f3687fe1216b522fdfe85367f5fed4787a93b83b06797ee14c943b4d.svg" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s1">&#39;(1+24)=33&#39;</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">EarleyParser</span><span class="p">(</span><span class="n">A3_GRAMMAR</span><span class="p">)</span>
<span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="n">mystring</span>
    <span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We now have a complete parser that can parse almost arbitrary <em>CFG</em>. There remains a small corner to fix – the case of epsilon rules as we will see later.</p>
</section>
<section id="ambiguous-parsing">
<h4>Ambiguous Parsing<a class="headerlink" href="#ambiguous-parsing" title="Link to this heading">#</a></h4>
<p>Ambiguous grammars are grammars that can produce multiple derivation trees for some given string. For example, the <code class="docutils literal notranslate"><span class="pre">A3_GRAMMAR</span></code> can parse <code class="docutils literal notranslate"><span class="pre">1+2+3</span></code> in two different ways – <code class="docutils literal notranslate"><span class="pre">[1+2]+3</span></code> and <code class="docutils literal notranslate"><span class="pre">1+[2+3]</span></code>.</p>
<p>Extracting a single tree might be reasonable for unambiguous parses. However, what if the given grammar produces ambiguity when given a string? We need to extract all derivation trees in that case. We enhance our <code class="docutils literal notranslate"><span class="pre">extract_trees()</span></code> method to extract multiple derivation trees.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">I</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EarleyParser</span><span class="p">(</span><span class="n">EarleyParser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">extract_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forest_node</span><span class="p">):</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">paths</span> <span class="o">=</span> <span class="n">forest_node</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">paths</span><span class="p">:</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">[])</span>

        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
            <span class="n">ptrees</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">extract_trees</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forest</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">))</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">I</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">ptrees</span><span class="p">):</span>
                <span class="k">yield</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>As before, we verify that everything works.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s1">&#39;1+2&#39;</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">EarleyParser</span><span class="p">(</span><span class="n">A1_GRAMMAR</span><span class="p">)</span>
<span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">mystring</span> <span class="o">==</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    <span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>One can also use a <code class="docutils literal notranslate"><span class="pre">GrammarFuzzer</span></code> to verify that everything works.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gf</span> <span class="o">=</span> <span class="n">GrammarFuzzer</span><span class="p">(</span><span class="n">A1_GRAMMAR</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">gf</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="n">s</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0 045+3+2-9+7-7-5-1-449
1 0+9+5-2+1-8+4-3+7+2
2 76413
3 9339
4 62
</pre></div>
</div>
</div>
</div>
</section>
<section id="the-aycock-epsilon-fix">
<h4>The Aycock Epsilon Fix<a class="headerlink" href="#the-aycock-epsilon-fix" title="Link to this heading">#</a></h4>
<p>While parsing, one often requires to know whether a given nonterminal can derive an empty string. For example, in the following grammar A can derive an empty string, while B can’t. The nonterminals that can derive an empty string are called <em>nullable</em> nonterminals. For example, in the below grammar <code class="docutils literal notranslate"><span class="pre">E_GRAMMAR_1</span></code>,  <code class="docutils literal notranslate"><span class="pre">&lt;A&gt;</span></code> is <em>nullable</em>, and since <code class="docutils literal notranslate"><span class="pre">&lt;A&gt;</span></code> is one of the alternatives of <code class="docutils literal notranslate"><span class="pre">&lt;start&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;start&gt;</span></code> is also <em>nullable</em>. But <code class="docutils literal notranslate"><span class="pre">&lt;B&gt;</span></code> is not <em>nullable</em>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">E_GRAMMAR_1</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;B&gt;&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;B&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>One of the problems with the original Earley implementation is that it does not handle rules that can derive empty strings very well. For example, the given grammar should match <code class="docutils literal notranslate"><span class="pre">a</span></code></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">EPSILON</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
<span class="n">E_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;S&gt;&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;S&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;A&gt;&lt;A&gt;&lt;A&gt;&lt;A&gt;&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;E&gt;&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;E&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">EPSILON</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">syntax_diagram</span><span class="p">(</span><span class="n">E_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>start
</pre></div>
</div>
<img alt="_images/8384f1d66e59b2b5b6d808ef51bd12508554bf77ae0c941231c892bc7c712e66.svg" src="_images/8384f1d66e59b2b5b6d808ef51bd12508554bf77ae0c941231c892bc7c712e66.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>S
</pre></div>
</div>
<img alt="_images/3240831eb5fc16a6dda5497933bf4fc7273ee66ec4eea9712448768932c7a79f.svg" src="_images/3240831eb5fc16a6dda5497933bf4fc7273ee66ec4eea9712448768932c7a79f.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>A
</pre></div>
</div>
<img alt="_images/56563db5c51701d7c8da1886fb38fa34a498683535c00d5e18292cc1d994504c.svg" src="_images/56563db5c51701d7c8da1886fb38fa34a498683535c00d5e18292cc1d994504c.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>E
</pre></div>
</div>
<img alt="_images/3103139f169a4b0f7c3e65ea00f91410be5f5fe6b29787287ece943b145034d5.svg" src="_images/3103139f169a4b0f7c3e65ea00f91410be5f5fe6b29787287ece943b145034d5.svg" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">EarleyParser</span><span class="p">(</span><span class="n">E_GRAMMAR</span><span class="p">)</span>
<span class="k">with</span> <span class="n">ExpectError</span><span class="p">():</span>
    <span class="n">trees</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Aycock et al.\cite{Aycock2002} suggests a simple fix. Their idea is to pre-compute the <code class="docutils literal notranslate"><span class="pre">nullable</span></code> set and use it to advance the <code class="docutils literal notranslate"><span class="pre">nullable</span></code> states. However, before we do that, we need to compute the <code class="docutils literal notranslate"><span class="pre">nullable</span></code> set. The <code class="docutils literal notranslate"><span class="pre">nullable</span></code> set consists of all nonterminals that can derive an empty string.</p>
<p>Computing the <code class="docutils literal notranslate"><span class="pre">nullable</span></code> set requires expanding each production rule in the grammar iteratively and inspecting whether a given rule can derive the empty string. Each iteration needs to take into account new terminals that have been found to be <code class="docutils literal notranslate"><span class="pre">nullable</span></code>. The procedure stops when we obtain a stable result. This procedure can be abstracted into a more general method <code class="docutils literal notranslate"><span class="pre">fixpoint</span></code>.</p>
<section id="fixpoint">
<h5>Fixpoint<a class="headerlink" href="#fixpoint" title="Link to this heading">#</a></h5>
<p>A <code class="docutils literal notranslate"><span class="pre">fixpoint</span></code> of a function is an element in the function’s domain such that it is mapped to itself. For example, 1 is a <code class="docutils literal notranslate"><span class="pre">fixpoint</span></code> of square root because <code class="docutils literal notranslate"><span class="pre">squareroot(1)</span> <span class="pre">==</span> <span class="pre">1</span></code>.</p>
<p>(We use <code class="docutils literal notranslate"><span class="pre">str</span></code> rather than <code class="docutils literal notranslate"><span class="pre">hash</span></code> to check for equality in <code class="docutils literal notranslate"><span class="pre">fixpoint</span></code> because the data structure <code class="docutils literal notranslate"><span class="pre">set</span></code>, which we would like to use as an argument has a good string representation but is not hashable).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fixpoint</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">helper</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">sarg</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="n">arg_</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">arg_</span><span class="p">)</span> <span class="o">==</span> <span class="n">sarg</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">arg</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">arg_</span>

    <span class="k">return</span> <span class="n">helper</span>
</pre></div>
</div>
</div>
</div>
<p>Remember <code class="docutils literal notranslate"><span class="pre">my_sqrt()</span></code> from <a class="reference internal" href="Intro_Testing.html"><span class="std std-doc">the first chapter</span></a>? We can define <code class="docutils literal notranslate"><span class="pre">my_sqrt()</span></code> using fixpoint.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">my_sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="nd">@fixpoint</span>
    <span class="k">def</span> <span class="nf">_my_sqrt</span><span class="p">(</span><span class="n">approx</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">approx</span> <span class="o">+</span> <span class="n">x</span> <span class="o">/</span> <span class="n">approx</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">return</span> <span class="n">_my_sqrt</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">my_sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.414213562373095
</pre></div>
</div>
</div>
</div>
</section>
<section id="nullable">
<h5>Nullable<a class="headerlink" href="#nullable" title="Link to this heading">#</a></h5>
<p>Similarly, we can define <code class="docutils literal notranslate"><span class="pre">nullable</span></code> using <code class="docutils literal notranslate"><span class="pre">fixpoint</span></code>. We essentially provide the definition of a single intermediate step. That is, assuming that <code class="docutils literal notranslate"><span class="pre">nullables</span></code> contain the current <code class="docutils literal notranslate"><span class="pre">nullable</span></code> nonterminals, we iterate over the grammar looking for productions which are <code class="docutils literal notranslate"><span class="pre">nullable</span></code> – that is, productions where the entire sequence can yield an empty string on some expansion.</p>
<p>We need to iterate over the different alternative expressions and their corresponding nonterminals. Hence we define a <code class="docutils literal notranslate"><span class="pre">rules()</span></code> method converts our dictionary representation to this pair format.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rules</span><span class="p">(</span><span class="n">grammar</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[(</span><span class="n">key</span><span class="p">,</span> <span class="n">choice</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">choices</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">choice</span> <span class="ow">in</span> <span class="n">choices</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">terminals()</span></code> method extracts all terminal symbols from a <code class="docutils literal notranslate"><span class="pre">canonical</span></code> grammar representation.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">terminals</span><span class="p">(</span><span class="n">grammar</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">token</span>
               <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">choice</span> <span class="ow">in</span> <span class="n">rules</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span>
               <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">choice</span> <span class="k">if</span> <span class="n">token</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">grammar</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">nullable_expr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">nullables</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">token</span> <span class="ow">in</span> <span class="n">nullables</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">expr</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">nullable</span><span class="p">(</span><span class="n">grammar</span><span class="p">):</span>
    <span class="n">productions</span> <span class="o">=</span> <span class="n">rules</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span>

    <span class="nd">@fixpoint</span>
    <span class="k">def</span> <span class="nf">nullable_</span><span class="p">(</span><span class="n">nullables</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">A</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">productions</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nullable_expr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">nullables</span><span class="p">):</span>
                <span class="n">nullables</span> <span class="o">|=</span> <span class="p">{</span><span class="n">A</span><span class="p">}</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">nullables</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">nullable_</span><span class="p">({</span><span class="n">EPSILON</span><span class="p">})</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">grammar</span> <span class="ow">in</span> <span class="p">{</span>
        <span class="s1">&#39;E_GRAMMAR&#39;</span><span class="p">:</span> <span class="n">E_GRAMMAR</span><span class="p">,</span>
        <span class="s1">&#39;E_GRAMMAR_1&#39;</span><span class="p">:</span> <span class="n">E_GRAMMAR_1</span>
<span class="p">}</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">nullable</span><span class="p">(</span><span class="n">canonical</span><span class="p">(</span><span class="n">grammar</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>E_GRAMMAR {&#39;&#39;, &#39;&lt;start&gt;&#39;, &#39;&lt;S&gt;&#39;, &#39;&lt;E&gt;&#39;, &#39;&lt;A&gt;&#39;}
E_GRAMMAR_1 {&#39;&#39;, &#39;&lt;start&gt;&#39;, &#39;&lt;A&gt;&#39;}
</pre></div>
</div>
</div>
</div>
<p>So, once we have the <code class="docutils literal notranslate"><span class="pre">nullable</span></code> set, all that we need to do is, after we have called <code class="docutils literal notranslate"><span class="pre">predict</span></code> on a state corresponding to a nonterminal, check if it is <code class="docutils literal notranslate"><span class="pre">nullable</span></code> and if it is, advance and add the state to the current column.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EarleyParser</span><span class="p">(</span><span class="n">EarleyParser</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span> <span class="o">=</span> <span class="n">nullable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cgrammar</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">alt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cgrammar</span><span class="p">[</span><span class="n">sym</span><span class="p">]:</span>
            <span class="n">col</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">State</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">alt</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span><span class="p">:</span>
            <span class="n">col</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">advance</span><span class="p">())</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">EarleyParser</span><span class="p">(</span><span class="n">E_GRAMMAR</span><span class="p">)</span>
<span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring</span><span class="p">):</span>
    <span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>To ensure that our parser does parse all kinds of grammars, let us try two more test cases.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">DIRECTLY_SELF_REFERRING</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;query&gt;&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;query&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;select &lt;expr&gt; from a&#39;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;expr&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;expr&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">],</span>
<span class="p">}</span>
<span class="n">INDIRECTLY_SELF_REFERRING</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;query&gt;&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;query&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;select &lt;expr&gt; from a&#39;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;expr&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;aexpr&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;aexpr&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;expr&gt;&quot;</span><span class="p">],</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s1">&#39;select a from a&#39;</span>
<span class="k">for</span> <span class="n">grammar</span> <span class="ow">in</span> <span class="p">[</span><span class="n">DIRECTLY_SELF_REFERRING</span><span class="p">,</span> <span class="n">INDIRECTLY_SELF_REFERRING</span><span class="p">]:</span>
    <span class="n">forest</span> <span class="o">=</span> <span class="n">EarleyParser</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;recognized&#39;</span><span class="p">,</span> <span class="n">mystring</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">forest</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">RecursionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Recursion error&quot;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>recognized select a from a
Recursion error maximum recursion depth exceeded
recognized select a from a
Recursion error maximum recursion depth exceeded
</pre></div>
</div>
</div>
</div>
<p>Why do we get recursion error here? The reason is that, our implementation of <code class="docutils literal notranslate"><span class="pre">extract_trees()</span></code> is eager. That is, it attempts to extract <em>all</em> inner parse trees before it can construct the outer parse tree. When there is a self reference, this results in recursion. Here is a simple extractor that avoids this problem. The idea here is that we randomly and lazily choose a node to expand, which avoids the infinite recursion.</p>
</section>
</section>
<section id="tree-extractor">
<h4>Tree Extractor<a class="headerlink" href="#tree-extractor" title="Link to this heading">#</a></h4>
<p>As you saw above, one of the problems with attempting to extract all trees is that the parse forest can consist of an infinite number of trees. So, here, we solve that problem by extracting one tree at a time.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SimpleExtractor</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parser</span> <span class="o">=</span> <span class="n">parser</span>
        <span class="n">cursor</span><span class="p">,</span> <span class="n">states</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_prefix</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">states</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">finished</span><span class="p">()),</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cursor</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">start</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s2">&quot;at &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">cursor</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">my_forest</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_forest</span><span class="p">(</span><span class="n">parser</span><span class="o">.</span><span class="n">table</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">extract_a_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forest_node</span><span class="p">):</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">paths</span> <span class="o">=</span> <span class="n">forest_node</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">paths</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">[]),</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">cur_path</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">choose_path</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>
        <span class="n">child_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pos_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">chart</span> <span class="ow">in</span> <span class="n">cur_path</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">forest</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">chart</span><span class="p">)</span>
            <span class="n">postree</span><span class="p">,</span> <span class="n">ntree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_a_node</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="n">child_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ntree</span><span class="p">)</span>
            <span class="n">pos_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">postree</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">length</span><span class="p">),</span> <span class="n">pos_nodes</span><span class="p">),</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">child_nodes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">choose_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="n">length</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">,</span> <span class="n">length</span>

    <span class="k">def</span> <span class="nf">extract_a_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">pos_tree</span><span class="p">,</span> <span class="n">parse_tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_a_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">my_forest</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">prune_tree</span><span class="p">(</span><span class="n">parse_tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Using it is as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">de</span> <span class="o">=</span> <span class="n">SimpleExtractor</span><span class="p">(</span><span class="n">EarleyParser</span><span class="p">(</span><span class="n">DIRECTLY_SELF_REFERRING</span><span class="p">),</span> <span class="n">mystring</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">de</span><span class="o">.</span><span class="n">extract_a_tree</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>select a from a
select a from a
select a from a
select a from a
select a from a
</pre></div>
</div>
</div>
</div>
<p>On the indirect reference:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ie</span> <span class="o">=</span> <span class="n">SimpleExtractor</span><span class="p">(</span><span class="n">EarleyParser</span><span class="p">(</span><span class="n">INDIRECTLY_SELF_REFERRING</span><span class="p">),</span> <span class="n">mystring</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">ie</span><span class="o">.</span><span class="n">extract_a_tree</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>select a from a
select a from a
select a from a
select a from a
select a from a
</pre></div>
</div>
</div>
</div>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">SimpleExtractor</span></code> gives no guarantee of the uniqueness of the returned trees. This can however be fixed by keeping track of the particular nodes that were expanded from <code class="docutils literal notranslate"><span class="pre">pos_tree</span></code> variable, and hence, avoiding exploration of the same paths.</p>
<p>For implementing this, we extract the random stream passing into the <code class="docutils literal notranslate"><span class="pre">SimpleExtractor</span></code>, and use it to control which nodes are explored. Different exploration paths can then form a tree of nodes.</p>
<p>We start with the node definition for a single choice. The <code class="docutils literal notranslate"><span class="pre">self._chosen</span></code> is the current choice made, <code class="docutils literal notranslate"><span class="pre">self.next</span></code> holds the next choice done using <code class="docutils literal notranslate"><span class="pre">self._chosen</span></code>. The <code class="docutils literal notranslate"><span class="pre">self.total</span></code> holds the total number of choices that one can have in this node.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ChoiceNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">total</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chosen</span> <span class="o">=</span> <span class="n">parent</span><span class="p">,</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_total</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">total</span><span class="p">,</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">chosen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">finished</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chosen</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%d</span><span class="s1">(</span><span class="si">%s</span><span class="s1">/</span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_i</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_chosen</span><span class="p">),</span>
                                 <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_total</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">next</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chosen</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">increment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># as soon as we increment, next becomes invalid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_chosen</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finished</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="o">.</span><span class="n">increment</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">finished</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chosen</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total</span>
</pre></div>
</div>
</div>
</div>
<p>Now we come to the enhanced <code class="docutils literal notranslate"><span class="pre">EnhancedExtractor()</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EnhancedExtractor</span><span class="p">(</span><span class="n">SimpleExtractor</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">choices</span> <span class="o">=</span> <span class="n">ChoiceNode</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>First we define <code class="docutils literal notranslate"><span class="pre">choose_path()</span></code> that given an array and a choice node, returns the element in array corresponding to the next choice node if it exists, or produces a new choice nodes, and returns that element.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EnhancedExtractor</span><span class="p">(</span><span class="n">EnhancedExtractor</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">choose_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">choices</span><span class="p">):</span>
        <span class="n">arr_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">choices</span><span class="o">.</span><span class="n">next</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">choices</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">finished</span><span class="p">():</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">choices</span><span class="o">.</span><span class="n">next</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">choices</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">ChoiceNode</span><span class="p">(</span><span class="n">choices</span><span class="p">,</span> <span class="n">arr_len</span><span class="p">)</span>
        <span class="n">next_choice</span> <span class="o">=</span> <span class="n">choices</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">chosen</span><span class="p">()</span>
        <span class="n">choices</span> <span class="o">=</span> <span class="n">choices</span><span class="o">.</span><span class="n">next</span>
        <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="n">next_choice</span><span class="p">],</span> <span class="n">next_choice</span><span class="p">,</span> <span class="n">arr_len</span><span class="p">,</span> <span class="n">choices</span>
</pre></div>
</div>
</div>
</div>
<p>We define <code class="docutils literal notranslate"><span class="pre">extract_a_node()</span></code> here. While extracting, we have a choice. Should we allow infinite forests, or should we have a finite number of trees with no direct recursion? A direct recursion is when there exists a parent node with the same nonterminal that parsed the same span. We choose here not to extract such trees. They can be added back after parsing.</p>
<p>This is a recursive procedure that inspects a node, extracts the path required to complete that node. A single path (corresponding to a nonterminal) may again be composed of a sequence of smaller paths. Such paths are again extracted using another call to <code class="docutils literal notranslate"><span class="pre">extract_a_node()</span></code> recursively.</p>
<p>What happens when we hit on one of the node recursions we want to avoid? In that case, we return the current choice node, which bubbles up to <code class="docutils literal notranslate"><span class="pre">extract_a_tree()</span></code>. That procedure increments the last choice, which in turn increments up the parents until we reach a choice node that still has options to explore.</p>
<p>What if we hit the end of choices for a particular choice node(i.e, we have exhausted paths that can be taken from a node)? In this case also, we return the current choice node, which bubbles up to <code class="docutils literal notranslate"><span class="pre">extract_a_tree()</span></code>.
That procedure increments the last choice, which bubbles up to the next choice that has some unexplored paths.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EnhancedExtractor</span><span class="p">(</span><span class="n">EnhancedExtractor</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">extract_a_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forest_node</span><span class="p">,</span> <span class="n">seen</span><span class="p">,</span> <span class="n">choices</span><span class="p">):</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">paths</span> <span class="o">=</span> <span class="n">forest_node</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">paths</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">[]),</span> <span class="n">choices</span>

        <span class="n">cur_path</span><span class="p">,</span> <span class="n">_i</span><span class="p">,</span> <span class="n">_l</span><span class="p">,</span> <span class="n">new_choices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">choose_path</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">choices</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cur_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">new_choices</span>
        <span class="n">child_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">chart</span> <span class="ow">in</span> <span class="n">cur_path</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span>
                <span class="n">child_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="p">[]))</span>
                <span class="k">continue</span>
            <span class="n">nid</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">s_col</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">e_col</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nid</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">new_choices</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">forest</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">chart</span><span class="p">)</span>
            <span class="n">ntree</span><span class="p">,</span> <span class="n">newer_choices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_a_node</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">seen</span> <span class="o">|</span> <span class="p">{</span><span class="n">nid</span><span class="p">},</span> <span class="n">new_choices</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ntree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">newer_choices</span>
            <span class="n">child_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ntree</span><span class="p">)</span>
            <span class="n">new_choices</span> <span class="o">=</span> <span class="n">newer_choices</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">child_nodes</span><span class="p">),</span> <span class="n">new_choices</span>
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">extract_a_tree()</span></code> is a depth first extractor of a single tree. It tries to extract a tree, and if the extraction returns <code class="docutils literal notranslate"><span class="pre">None</span></code>, it means that a particular choice was exhausted, or we hit on a recursion. In that case, we increment the choice, and explore a new path.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EnhancedExtractor</span><span class="p">(</span><span class="n">EnhancedExtractor</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">extract_a_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">choices</span><span class="o">.</span><span class="n">finished</span><span class="p">():</span>
            <span class="n">parse_tree</span><span class="p">,</span> <span class="n">choices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_a_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">my_forest</span><span class="p">,</span> <span class="nb">set</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">choices</span><span class="p">)</span>
            <span class="n">choices</span><span class="o">.</span><span class="n">increment</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">parse_tree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">prune_tree</span><span class="p">(</span><span class="n">parse_tree</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
</pre></div>
</div>
</div>
</div>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">EnhancedExtractor</span></code> only extracts nodes that are not directly recursive. That is, if it finds a node with a nonterminal that covers the same span as that of a parent node with the same nonterminal, it skips the node.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ee</span> <span class="o">=</span> <span class="n">EnhancedExtractor</span><span class="p">(</span><span class="n">EarleyParser</span><span class="p">(</span><span class="n">INDIRECTLY_SELF_REFERRING</span><span class="p">),</span> <span class="n">mystring</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">ee</span><span class="o">.</span><span class="n">extract_a_tree</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">break</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">s</span> <span class="o">==</span> <span class="n">mystring</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1 (&#39;&lt;start&gt;&#39;, [(&#39;&lt;query&gt;&#39;, [(&#39;select &#39;, []), (&#39;&lt;expr&gt;&#39;, [(&#39;a&#39;, [])]), (&#39; from a&#39;, [])])])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">istring</span> <span class="o">=</span> <span class="s1">&#39;1+2+3+4&#39;</span>
<span class="n">ee</span> <span class="o">=</span> <span class="n">EnhancedExtractor</span><span class="p">(</span><span class="n">EarleyParser</span><span class="p">(</span><span class="n">A1_GRAMMAR</span><span class="p">),</span> <span class="n">istring</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">ee</span><span class="o">.</span><span class="n">extract_a_tree</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">break</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">s</span> <span class="o">==</span> <span class="n">istring</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1 (&#39;&lt;start&gt;&#39;, [(&#39;&lt;expr&gt;&#39;, [(&#39;&lt;expr&gt;&#39;, [(&#39;&lt;expr&gt;&#39;, [(&#39;&lt;expr&gt;&#39;, [(&#39;&lt;integer&gt;&#39;, [(&#39;&lt;digit&gt;&#39;, [(&#39;1&#39;, [])])])]), (&#39;+&#39;, []), (&#39;&lt;expr&gt;&#39;, [(&#39;&lt;integer&gt;&#39;, [(&#39;&lt;digit&gt;&#39;, [(&#39;2&#39;, [])])])])]), (&#39;+&#39;, []), (&#39;&lt;expr&gt;&#39;, [(&#39;&lt;integer&gt;&#39;, [(&#39;&lt;digit&gt;&#39;, [(&#39;3&#39;, [])])])])]), (&#39;+&#39;, []), (&#39;&lt;expr&gt;&#39;, [(&#39;&lt;integer&gt;&#39;, [(&#39;&lt;digit&gt;&#39;, [(&#39;4&#39;, [])])])])])])
2 (&#39;&lt;start&gt;&#39;, [(&#39;&lt;expr&gt;&#39;, [(&#39;&lt;expr&gt;&#39;, [(&#39;&lt;expr&gt;&#39;, [(&#39;&lt;integer&gt;&#39;, [(&#39;&lt;digit&gt;&#39;, [(&#39;1&#39;, [])])])]), (&#39;+&#39;, []), (&#39;&lt;expr&gt;&#39;, [(&#39;&lt;expr&gt;&#39;, [(&#39;&lt;integer&gt;&#39;, [(&#39;&lt;digit&gt;&#39;, [(&#39;2&#39;, [])])])]), (&#39;+&#39;, []), (&#39;&lt;expr&gt;&#39;, [(&#39;&lt;integer&gt;&#39;, [(&#39;&lt;digit&gt;&#39;, [(&#39;3&#39;, [])])])])])]), (&#39;+&#39;, []), (&#39;&lt;expr&gt;&#39;, [(&#39;&lt;integer&gt;&#39;, [(&#39;&lt;digit&gt;&#39;, [(&#39;4&#39;, [])])])])])])
3 (&#39;&lt;start&gt;&#39;, [(&#39;&lt;expr&gt;&#39;, [(&#39;&lt;expr&gt;&#39;, [(&#39;&lt;expr&gt;&#39;, [(&#39;&lt;integer&gt;&#39;, [(&#39;&lt;digit&gt;&#39;, [(&#39;1&#39;, [])])])]), (&#39;+&#39;, []), (&#39;&lt;expr&gt;&#39;, [(&#39;&lt;integer&gt;&#39;, [(&#39;&lt;digit&gt;&#39;, [(&#39;2&#39;, [])])])])]), (&#39;+&#39;, []), (&#39;&lt;expr&gt;&#39;, [(&#39;&lt;expr&gt;&#39;, [(&#39;&lt;integer&gt;&#39;, [(&#39;&lt;digit&gt;&#39;, [(&#39;3&#39;, [])])])]), (&#39;+&#39;, []), (&#39;&lt;expr&gt;&#39;, [(&#39;&lt;integer&gt;&#39;, [(&#39;&lt;digit&gt;&#39;, [(&#39;4&#39;, [])])])])])])])
4 (&#39;&lt;start&gt;&#39;, [(&#39;&lt;expr&gt;&#39;, [(&#39;&lt;expr&gt;&#39;, [(&#39;&lt;integer&gt;&#39;, [(&#39;&lt;digit&gt;&#39;, [(&#39;1&#39;, [])])])]), (&#39;+&#39;, []), (&#39;&lt;expr&gt;&#39;, [(&#39;&lt;expr&gt;&#39;, [(&#39;&lt;expr&gt;&#39;, [(&#39;&lt;integer&gt;&#39;, [(&#39;&lt;digit&gt;&#39;, [(&#39;2&#39;, [])])])]), (&#39;+&#39;, []), (&#39;&lt;expr&gt;&#39;, [(&#39;&lt;integer&gt;&#39;, [(&#39;&lt;digit&gt;&#39;, [(&#39;3&#39;, [])])])])]), (&#39;+&#39;, []), (&#39;&lt;expr&gt;&#39;, [(&#39;&lt;integer&gt;&#39;, [(&#39;&lt;digit&gt;&#39;, [(&#39;4&#39;, [])])])])])])])
5 (&#39;&lt;start&gt;&#39;, [(&#39;&lt;expr&gt;&#39;, [(&#39;&lt;expr&gt;&#39;, [(&#39;&lt;integer&gt;&#39;, [(&#39;&lt;digit&gt;&#39;, [(&#39;1&#39;, [])])])]), (&#39;+&#39;, []), (&#39;&lt;expr&gt;&#39;, [(&#39;&lt;expr&gt;&#39;, [(&#39;&lt;integer&gt;&#39;, [(&#39;&lt;digit&gt;&#39;, [(&#39;2&#39;, [])])])]), (&#39;+&#39;, []), (&#39;&lt;expr&gt;&#39;, [(&#39;&lt;expr&gt;&#39;, [(&#39;&lt;integer&gt;&#39;, [(&#39;&lt;digit&gt;&#39;, [(&#39;3&#39;, [])])])]), (&#39;+&#39;, []), (&#39;&lt;expr&gt;&#39;, [(&#39;&lt;integer&gt;&#39;, [(&#39;&lt;digit&gt;&#39;, [(&#39;4&#39;, [])])])])])])])])
</pre></div>
</div>
</div>
</div>
</section>
<section id="more-earley-parsing">
<h4>More Earley Parsing<a class="headerlink" href="#more-earley-parsing" title="Link to this heading">#</a></h4>
<p>A number of other optimizations exist for Earley parsers. A fast industrial strength Earley parser implementation is the <a class="reference external" href="https://jeffreykegler.github.io/Marpa-web-site/">Marpa parser</a>. Further, Earley parsing need not be restricted to character data. One may also parse streams (audio and video streams) \cite{qi2018generalized} using a generalized Earley parser.</p>
</section>
</section>
<section id="id4">
<h3>End of Excursion<a class="headerlink" href="#id4" title="Link to this heading">#</a></h3>
<p>Here are a few examples of the Earley parser in action.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s2">&quot;1 + (2 * 3)&quot;</span>
<span class="n">earley</span> <span class="o">=</span> <span class="n">EarleyParser</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
<span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">earley</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="n">mystring</span>
    <span class="n">display</span><span class="p">(</span><span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/41a8b9cbd9065249a2fdd9beedcb7feaee897ae1750dbeb3c0fc16160134284c.svg" src="_images/41a8b9cbd9065249a2fdd9beedcb7feaee897ae1750dbeb3c0fc16160134284c.svg" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s2">&quot;1 * (2 + 3.35)&quot;</span>
<span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">earley</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="n">mystring</span>
    <span class="n">display</span><span class="p">(</span><span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/2f26aaa6c2058d965a174828930b0978ae89c39cb7c02100d40b80cf654246bc.svg" src="_images/2f26aaa6c2058d965a174828930b0978ae89c39cb7c02100d40b80cf654246bc.svg" />
</div>
</div>
<p>In contrast to the <code class="docutils literal notranslate"><span class="pre">PEGParser</span></code>, above, the <code class="docutils literal notranslate"><span class="pre">EarleyParser</span></code> can handle arbitrary context-free grammars.</p>
</section>
<section id="excursion-testing-the-parsers">
<h3>Excursion: Testing the Parsers<a class="headerlink" href="#excursion-testing-the-parsers" title="Link to this heading">#</a></h3>
<p>While we have defined two parser variants, it would be nice to have some confirmation that our parses work well. While it is possible to formally prove that they work, it is much more satisfying to generate random grammars, their corresponding strings, and parse them using the same grammar.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">prod_line_grammar</span><span class="p">(</span><span class="n">nonterminals</span><span class="p">,</span> <span class="n">terminals</span><span class="p">):</span>
    <span class="n">g</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;symbols&gt;&#39;</span><span class="p">],</span>
        <span class="s1">&#39;&lt;symbols&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;symbol&gt;&lt;symbols&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;symbol&gt;&#39;</span><span class="p">],</span>
        <span class="s1">&#39;&lt;symbol&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;nonterminals&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;terminals&gt;&#39;</span><span class="p">],</span>
        <span class="s1">&#39;&lt;nonterminals&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;lt&gt;&lt;alpha&gt;&lt;gt&gt;&#39;</span><span class="p">],</span>
        <span class="s1">&#39;&lt;lt&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;&#39;</span><span class="p">],</span>
        <span class="s1">&#39;&lt;gt&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&gt;&#39;</span><span class="p">],</span>
        <span class="s1">&#39;&lt;alpha&gt;&#39;</span><span class="p">:</span> <span class="n">nonterminals</span><span class="p">,</span>
        <span class="s1">&#39;&lt;terminals&gt;&#39;</span><span class="p">:</span> <span class="n">terminals</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">nonterminals</span><span class="p">:</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;&lt;nonterminals&gt;&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">g</span><span class="p">[</span><span class="s1">&#39;&lt;lt&gt;&#39;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">g</span><span class="p">[</span><span class="s1">&#39;&lt;alpha&gt;&#39;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">g</span><span class="p">[</span><span class="s1">&#39;&lt;gt&gt;&#39;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">g</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">syntax_diagram</span><span class="p">(</span><span class="n">prod_line_grammar</span><span class="p">([</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>start
</pre></div>
</div>
<img alt="_images/bbe4748191fff35742bafbe2eaead1b4cbc866accb5202d4a9840335313adec2.svg" src="_images/bbe4748191fff35742bafbe2eaead1b4cbc866accb5202d4a9840335313adec2.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>symbols
</pre></div>
</div>
<img alt="_images/ed9eaef0f095c7c04c3d67cced22e536aaa1749e45729af62aca6c3dd8e74f93.svg" src="_images/ed9eaef0f095c7c04c3d67cced22e536aaa1749e45729af62aca6c3dd8e74f93.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>symbol
</pre></div>
</div>
<img alt="_images/e50c4cc158053d057d018d12a63a967b175dc1f7673f637f47bc6f103df0a9c1.svg" src="_images/e50c4cc158053d057d018d12a63a967b175dc1f7673f637f47bc6f103df0a9c1.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>nonterminals
</pre></div>
</div>
<img alt="_images/8ebdae3933360abad4be4356e2d268687c520591ccc5f3f7a7aca70f8bbf5ad7.svg" src="_images/8ebdae3933360abad4be4356e2d268687c520591ccc5f3f7a7aca70f8bbf5ad7.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>lt
</pre></div>
</div>
<img alt="_images/5fca9541bdda2f0a623c8880887a0f168a4e8f793499d04b80f2e267704fed80.svg" src="_images/5fca9541bdda2f0a623c8880887a0f168a4e8f793499d04b80f2e267704fed80.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>gt
</pre></div>
</div>
<img alt="_images/2570c2b2f3687fe1216b522fdfe85367f5fed4787a93b83b06797ee14c943b4d.svg" src="_images/2570c2b2f3687fe1216b522fdfe85367f5fed4787a93b83b06797ee14c943b4d.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>alpha
</pre></div>
</div>
<img alt="_images/0a389a07a37ed22beda3bc8741b8f35dcd2b69c39f3af2612b0bdcb61f49de5c.svg" src="_images/0a389a07a37ed22beda3bc8741b8f35dcd2b69c39f3af2612b0bdcb61f49de5c.svg" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>terminals
</pre></div>
</div>
<img alt="_images/2d7dd91cf713d5416b98b73c081616b8656b3fb271fb23cd96659a51363e97a6.svg" src="_images/2d7dd91cf713d5416b98b73c081616b8656b3fb271fb23cd96659a51363e97a6.svg" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">make_rule</span><span class="p">(</span><span class="n">nonterminals</span><span class="p">,</span> <span class="n">terminals</span><span class="p">,</span> <span class="n">num_alts</span><span class="p">):</span>
    <span class="n">prod_grammar</span> <span class="o">=</span> <span class="n">prod_line_grammar</span><span class="p">(</span><span class="n">nonterminals</span><span class="p">,</span> <span class="n">terminals</span><span class="p">)</span>

    <span class="n">gf</span> <span class="o">=</span> <span class="n">GrammarFuzzer</span><span class="p">(</span><span class="n">prod_grammar</span><span class="p">,</span> <span class="n">min_nonterminals</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">max_nonterminals</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">choices</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">ascii_uppercase</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">[</span><span class="n">gf</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_alts</span><span class="p">)])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">make_rule</span><span class="p">([</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(&#39;&lt;FYU&gt;&#39;, [&#39;&lt;C&gt;23&#39;, &#39;&lt;C&gt;&lt;A&gt;&#39;, &#39;&lt;B&gt;&lt;C&gt;3&#39;])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Grammars</span> <span class="kn">import</span> <span class="n">unreachable_nonterminals</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">make_grammar</span><span class="p">(</span><span class="n">num_symbols</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">num_alts</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">terminals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">ascii_lowercase</span><span class="p">)</span>
    <span class="n">grammar</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_symbols</span><span class="p">):</span>
        <span class="n">nonterminals</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">expansions</span> <span class="o">=</span> \
            <span class="n">make_rule</span><span class="p">(</span><span class="n">nonterminals</span><span class="p">,</span> <span class="n">terminals</span><span class="p">,</span> <span class="n">num_alts</span><span class="p">)</span>
        <span class="n">grammar</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">expansions</span>

    <span class="n">grammar</span><span class="p">[</span><span class="n">START_SYMBOL</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>

    <span class="c1"># Remove unused parts</span>
    <span class="k">for</span> <span class="n">nonterminal</span> <span class="ow">in</span> <span class="n">unreachable_nonterminals</span><span class="p">(</span><span class="n">grammar</span><span class="p">):</span>
        <span class="k">del</span> <span class="n">grammar</span><span class="p">[</span><span class="n">nonterminal</span><span class="p">]</span>

    <span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">grammar</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">make_grammar</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;&lt;ILY&gt;&#39;: [&#39;lhp&#39;, &#39;gta&#39;, &#39;sm&#39;],
 &#39;&lt;FZD&gt;&#39;: [&#39;qn&lt;ILY&gt;&#39;, &#39;e&lt;ILY&gt;&lt;ILY&gt;g&#39;, &#39;&lt;ILY&gt;f&lt;ILY&gt;m&#39;],
 &#39;&lt;ITK&gt;&#39;: [&#39;&lt;ILY&gt;fyy&#39;, &#39;&lt;ILY&gt;&lt;ILY&gt;t&#39;, &#39;&lt;FZD&gt;l&lt;ILY&gt;ao&#39;],
 &#39;&lt;start&gt;&#39;: [&#39;&lt;ITK&gt;&#39;]}
</pre></div>
</div>
</div>
</div>
<p>Now we verify if our arbitrary grammars can be used by the Earley parser.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">my_grammar</span> <span class="o">=</span> <span class="n">make_grammar</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">my_grammar</span><span class="p">)</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">EarleyParser</span><span class="p">(</span><span class="n">my_grammar</span><span class="p">)</span>
    <span class="n">mygf</span> <span class="o">=</span> <span class="n">GrammarFuzzer</span><span class="p">(</span><span class="n">my_grammar</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">mygf</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="n">s</span>
        <span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;&lt;SCS&gt;&#39;: [&#39;ts&#39;, &#39;f&#39;, &#39;ng&#39;], &#39;&lt;BQN&gt;&#39;: [&#39;wm&lt;SCS&gt;&#39;, &#39;&lt;SCS&gt;wi&#39;, &#39;&lt;SCS&gt;hw&#39;], &#39;&lt;UZC&gt;&#39;: [&#39;gyk&lt;BQN&gt;br&#39;, &#39;&lt;SCS&gt;iqp&#39;, &#39;&lt;BQN&gt;vb&#39;], &#39;&lt;start&gt;&#39;: [&#39;&lt;UZC&gt;&#39;]}
fhwvb
{&#39;&lt;CRN&gt;&#39;: [&#39;meze&#39;, &#39;de&#39;, &#39;cpcv&#39;], &#39;&lt;AIS&gt;&#39;: [&#39;&lt;CRN&gt;hb&#39;, &#39;dc&lt;CRN&gt;&#39;, &#39;pa&lt;CRN&gt;x&#39;], &#39;&lt;MAO&gt;&#39;: [&#39;&lt;CRN&gt;su&#39;, &#39;&lt;CRN&gt;hj&#39;, &#39;&lt;CRN&gt;&lt;AIS&gt;g&#39;], &#39;&lt;start&gt;&#39;: [&#39;&lt;MAO&gt;&#39;]}
dehj
{&#39;&lt;MFY&gt;&#39;: [&#39;y&#39;, &#39;w&#39;, &#39;&#39;], &#39;&lt;ZOY&gt;&#39;: [&#39;oe&lt;MFY&gt;&#39;, &#39;h&lt;MFY&gt;u&#39;, &#39;lowr&#39;], &#39;&lt;HFT&gt;&#39;: [&#39;&lt;ZOY&gt;ro&#39;, &#39;&lt;ZOY&gt;w&#39;, &#39;&lt;ZOY&gt;&lt;ZOY&gt;w&#39;], &#39;&lt;start&gt;&#39;: [&#39;&lt;HFT&gt;&#39;]}
lowrro
{&#39;&lt;CYC&gt;&#39;: [&#39;cg&#39;, &#39;enl&#39;, &#39;ovd&#39;], &#39;&lt;TUV&gt;&#39;: [&#39;&lt;CYC&gt;hf&#39;, &#39;&lt;CYC&gt;nl&#39;, &#39;fhg&#39;], &#39;&lt;MOQ&gt;&#39;: [&#39;g&lt;TUV&gt;g&#39;, &#39;&lt;CYC&gt;ix&#39;, &#39;&lt;CYC&gt;&lt;TUV&gt;&lt;CYC&gt;&#39;], &#39;&lt;start&gt;&#39;: [&#39;&lt;MOQ&gt;&#39;]}
cgix
{&#39;&lt;WJJ&gt;&#39;: [&#39;dszdlh&#39;, &#39;j&#39;, &#39;fd&#39;], &#39;&lt;RQM&gt;&#39;: [&#39;&lt;WJJ&gt;wx&#39;, &#39;xs&lt;WJJ&gt;&lt;WJJ&gt;&#39;, &#39;&lt;WJJ&gt;x&#39;], &#39;&lt;JNY&gt;&#39;: [&#39;&lt;WJJ&gt;oa&#39;, &#39;&lt;WJJ&gt;&lt;WJJ&gt;cx&#39;, &#39;xd&lt;RQM&gt;&#39;], &#39;&lt;start&gt;&#39;: [&#39;&lt;JNY&gt;&#39;]}
joa
</pre></div>
</div>
</div>
</div>
<p>With this, we have completed both implementation and testing of <em>arbitrary</em> CFG, which can now be used along with <code class="docutils literal notranslate"><span class="pre">LangFuzzer</span></code> to generate better fuzzing inputs.</p>
</section>
<section id="id5">
<h3>End of Excursion<a class="headerlink" href="#id5" title="Link to this heading">#</a></h3>
</section>
</section>
<section id="background">
<h2>Background<a class="headerlink" href="#background" title="Link to this heading">#</a></h2>
<p>Numerous parsing techniques exist that can parse a given string using a
given grammar, and produce corresponding derivation tree or trees. However,
some of these techniques work only on specific classes of grammars.
These classes of grammars are named after the specific kind of parser
that can accept grammars of that category. That is, the upper bound for
the capabilities of the parser defines the grammar class named after that
parser.</p>
<p>The <em>LL</em> and <em>LR</em> parsing are the main traditions in parsing. Here, <em>LL</em> means left-to-right, leftmost derivation, and it represents a top-down approach. On the other hand, and LR (left-to-right, rightmost derivation) represents a bottom-up approach. Another way to look at it is that LL parsers compute the derivation tree incrementally in <em>pre-order</em> while LR parsers compute the derivation tree in <em>post-order</em> \cite{pingali2015graphical}).</p>
<p>Different classes of grammars differ in the features that are available to
the user for writing a grammar of that class. That is, the corresponding
kind of parser will be unable to parse a grammar that makes use of more
features than allowed. For example, the <code class="docutils literal notranslate"><span class="pre">A2_GRAMMAR</span></code> is an <em>LL</em>
grammar because it lacks left recursion, while <code class="docutils literal notranslate"><span class="pre">A1_GRAMMAR</span></code> is not an
<em>LL</em> grammar. This is because an <em>LL</em> parser parses
its input from left to right, and constructs the leftmost derivation of its
input by expanding the nonterminals it encounters. If there is a left
recursion in one of these rules, an <em>LL</em> parser will enter an infinite loop.</p>
<p>Similarly, a grammar is LL(k) if it can be parsed by an LL parser with k lookahead token, and LR(k) grammar can only be parsed with LR parser with at least k lookahead tokens. These grammars are interesting because both LL(k) and LR(k) grammars have <span class="math notranslate nohighlight">\(O(n)\)</span> parsers, and can be used with relatively restricted computational budget compared to other grammars.</p>
<p>The languages for which one can provide an <em>LL(k)</em> grammar is called <em>LL(k)</em> languages (where k is the minimum lookahead required). Similarly, <em>LR(k)</em> is defined as the set of languages that have an <em>LR(k)</em> grammar. In terms of languages, LL(k) <span class="math notranslate nohighlight">\(\subset\)</span> LL(k+1) and LL(k) <span class="math notranslate nohighlight">\(\subset\)</span> LR(k), and <em>LR(k)</em> <span class="math notranslate nohighlight">\(=\)</span> <em>LR(1)</em>. All deterministic <em>CFLs</em> have an <em>LR(1)</em> grammar. However, there exist <em>CFLs</em> that are inherently ambiguous \cite{ogden1968helpful}, and for these, one can’t provide an <em>LR(1)</em> grammar.</p>
<p>The other main parsing algorithms for <em>CFGs</em> are GLL \cite{scott2010gll}, GLR \cite{tomita1987efficient,tomita2012generalized}, and CYK \cite{grune2008parsing}.
The ALL(*) (used by ANTLR) on the other hand is a grammar representation that uses <em>Regular Expression</em> like predicates (similar to advanced PEGs – see <a class="reference internal" href="#Exercise-3:-PEG-Predicates"><span class="xref myst">Exercise</span></a>) rather than a fixed lookahead. Hence, ALL(*) can accept a larger class of grammars than CFGs.</p>
<p>In terms of computational limits of parsing, the main CFG parsers have a complexity of <span class="math notranslate nohighlight">\(O(n^3)\)</span> for arbitrary grammars. However, parsing with arbitrary <em>CFG</em> is reducible to boolean matrix multiplication \cite{Valiant1975} (and the reverse \cite{Lee2002}). This is at present bounded by <span class="math notranslate nohighlight">\(O(2^{23728639})\)</span> \cite{LeGall2014}. Hence, worse case complexity for parsing arbitrary CFG is likely to remain close to cubic.</p>
<p>Regarding PEGs, the actual class of languages that is expressible in <em>PEG</em> is currently unknown. In particular, we know that <em>PEGs</em> can express certain languages such as <span class="math notranslate nohighlight">\(a^n b^n c^n\)</span>. However, we do not know if there exist <em>CFLs</em> that are not expressible with <em>PEGs</em>. In Section 2.3, we provided an instance of a counter-intuitive PEG grammar. While important for our purposes (we use grammars for generation of inputs) this is not a criticism of parsing with PEGs. PEG focuses on writing grammars for recognizing a given language, and not necessarily in interpreting what language an arbitrary PEG might yield. Given a Context-Free Language to parse, it is almost always possible to write a grammar for it in PEG, and given that 1) a PEG can parse any string in <span class="math notranslate nohighlight">\(O(n)\)</span> time, and 2) at present we know of no CFL that can’t be expressed as a PEG, and 3) compared with <em>LR</em> grammars, a PEG is often more intuitive because it allows top-down interpretation, when writing a parser for a language, PEGs should be under serious consideration.</p>
</section>
<section id="id6">
<h2>Synopsis<a class="headerlink" href="#id6" title="Link to this heading">#</a></h2>
<p>This chapter introduces <code class="docutils literal notranslate"><span class="pre">Parser</span></code> classes, parsing a string into a <em>derivation tree</em> as introduced in the <a class="reference internal" href="GrammarFuzzer.html"><span class="std std-doc">chapter on efficient grammar fuzzing</span></a>.  Two important parser classes are provided:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Parsing-Expression-Grammars"><span class="xref myst">Parsing Expression Grammar parsers</span></a> (<code class="docutils literal notranslate"><span class="pre">PEGParser</span></code>). These are very efficient, but limited to specific grammar structure. Notably, the alternatives represent <em>ordered choice</em>. That is, rather than choosing all rules that can potentially match, we stop at the first match that succeed.</p></li>
<li><p><a class="reference internal" href="#Parsing-Context-Free-Grammars"><span class="xref myst">Earley parsers</span></a> (<code class="docutils literal notranslate"><span class="pre">EarleyParser</span></code>). These accept any kind of context-free grammars, and explore all parsing alternatives (if any).</p></li>
</ul>
<p>Using any of these is fairly easy, though.  First, instantiate them with a grammar:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Grammars</span> <span class="kn">import</span> <span class="n">US_PHONE_GRAMMAR</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">us_phone_parser</span> <span class="o">=</span> <span class="n">EarleyParser</span><span class="p">(</span><span class="n">US_PHONE_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Then, use the <code class="docutils literal notranslate"><span class="pre">parse()</span></code> method to retrieve a list of possible derivation trees:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">trees</span> <span class="o">=</span> <span class="n">us_phone_parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;(555)987-6543&quot;</span><span class="p">)</span>
<span class="n">tree</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">trees</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/f131dcbbf8e593fb5d0518a4f735f2dcb285712def81a0b43646340101bbb2fc.svg" src="_images/f131dcbbf8e593fb5d0518a4f735f2dcb285712def81a0b43646340101bbb2fc.svg" />
</div>
</div>
<p>These derivation trees can then be used for test generation, notably for mutating and recombining existing inputs.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># ignore</span>
<span class="kn">from</span> <span class="nn">ClassDiagram</span> <span class="kn">import</span> <span class="n">display_class_hierarchy</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># ignore</span>
<span class="n">display_class_hierarchy</span><span class="p">([</span><span class="n">PEGParser</span><span class="p">,</span> <span class="n">EarleyParser</span><span class="p">],</span>
                        <span class="n">public_methods</span><span class="o">=</span><span class="p">[</span>
                            <span class="n">Parser</span><span class="o">.</span><span class="n">parse</span><span class="p">,</span>
                            <span class="n">Parser</span><span class="o">.</span><span class="fm">__init__</span><span class="p">,</span>
                            <span class="n">Parser</span><span class="o">.</span><span class="n">grammar</span><span class="p">,</span>
                            <span class="n">Parser</span><span class="o">.</span><span class="n">start_symbol</span>
                        <span class="p">],</span>
                        <span class="n">types</span><span class="o">=</span><span class="p">{</span>
                            <span class="s1">&#39;DerivationTree&#39;</span><span class="p">:</span> <span class="n">DerivationTree</span><span class="p">,</span>
                            <span class="s1">&#39;Grammar&#39;</span><span class="p">:</span> <span class="n">Grammar</span>
                        <span class="p">},</span>
                        <span class="n">project</span><span class="o">=</span><span class="s1">&#39;fuzzingbook&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 12.2.1 (20241206.2353)
 -->
<!-- Pages: 1 -->
<svg width="382pt" height="395pt"
 viewBox="0.00 0.00 381.62 394.50" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 390.5)">
<g id="a_graph0"><a xlink:title="PEGParser class hierarchy">
<polygon fill="white" stroke="none" points="-4,4 -4,-390.5 377.62,-390.5 377.62,4 -4,4"/>
</a>
</g>
<!-- PEGParser -->
<g id="node1" class="node">
<title>PEGParser</title>
<g id="a_node1"><a xlink:href="#" xlink:title="class PEGParser:&#10;Packrat parser for Parsing Expression Grammars (PEGs).">
<polygon fill="none" stroke="black" points="0,-70.62 0,-142.88 100,-142.88 100,-70.62 0,-70.62"/>
<text text-anchor="start" x="18.12" y="-126.58" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">PEGParser</text>
<polyline fill="none" stroke="black" points="0,-116.88 100,-116.88"/>
<g id="a_node1_0"><a xlink:href="#" xlink:title="PEGParser">
<g id="a_node1_1"><a xlink:href="#" xlink:title="parse_prefix(self, text):&#10;Return pair (cursor, forest) for longest prefix of text.&#10;To be defined in subclasses.">
<text text-anchor="start" x="8" y="-104.38" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="10.00">parse_prefix()</text>
</a>
</g>
<g id="a_node1_2"><a xlink:href="#" xlink:title="unify_rule(self, rule, text, at)">
<text text-anchor="start" x="8" y="-90.62" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">unify_rule()</text>
</a>
</g>
<g id="a_node1_3"><a xlink:href="#" xlink:title="unify_key(self, key, text, at=0)">
<text text-anchor="start" x="8" y="-77.88" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">unify_key()</text>
</a>
</g>
</a>
</g>
</a>
</g>
</g>
<!-- Parser -->
<g id="node2" class="node">
<title>Parser</title>
<g id="a_node2"><a xlink:href="#" xlink:title="class Parser:&#10;Base class for parsing.">
<polygon fill="none" stroke="black" points="63,-250 63,-386 163,-386 163,-250 63,-250"/>
<text text-anchor="start" x="93.5" y="-369.7" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">Parser</text>
<polyline fill="none" stroke="black" points="63,-360 163,-360"/>
<g id="a_node2_4"><a xlink:href="#" xlink:title="Parser">
<g id="a_node2_5"><a xlink:href="#" xlink:title="__init__(self, grammar, **kwargs):&#10;Constructor.&#10;`grammar` is the grammar to be used for parsing.&#10;Keyword arguments:&#10;`start_symbol` is the start symbol (default: &#39;&lt;start&gt;&#39;).&#10;`log` enables logging (default: False).&#10;`coalesce` defines if tokens should be coalesced (default: True).&#10;`tokens`, if set, is a set of tokens to be used.">
<text text-anchor="start" x="71" y="-347.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">__init__()</text>
</a>
</g>
<g id="a_node2_6"><a xlink:href="#" xlink:title="grammar(self) &#45;&gt; Grammar:&#10;Return the grammar of this parser.">
<text text-anchor="start" x="71" y="-334.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">grammar()</text>
</a>
</g>
<g id="a_node2_7"><a xlink:href="#" xlink:title="parse(self, text: str) &#45;&gt; Iterable[DerivationTree]:&#10;Parse `text` using the grammar.&#10;Return an iterable of parse trees.">
<text text-anchor="start" x="71" y="-322" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">parse()</text>
</a>
</g>
<g id="a_node2_8"><a xlink:href="#" xlink:title="start_symbol(self) &#45;&gt; str:&#10;Return the start symbol of this parser.">
<text text-anchor="start" x="71" y="-309.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">start_symbol()</text>
</a>
</g>
<g id="a_node2_9"><a xlink:href="#" xlink:title="coalesce(self, children: List[DerivationTree]) &#45;&gt; List[DerivationTree]">
<text text-anchor="start" x="71" y="-295.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">coalesce()</text>
</a>
</g>
<g id="a_node2_10"><a xlink:href="#" xlink:title="parse_on(self, text: str, start_symbol: str) &#45;&gt; Generator">
<text text-anchor="start" x="71" y="-282.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">parse_on()</text>
</a>
</g>
<g id="a_node2_11"><a xlink:href="#" xlink:title="parse_prefix(self, text: str) &#45;&gt; Tuple[int, Iterable[DerivationTree]]:&#10;Return pair (cursor, forest) for longest prefix of text.&#10;To be defined in subclasses.">
<text text-anchor="start" x="71" y="-271" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="10.00">parse_prefix()</text>
</a>
</g>
<g id="a_node2_12"><a xlink:href="#" xlink:title="prune_tree(self, tree)">
<text text-anchor="start" x="71" y="-257.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">prune_tree()</text>
</a>
</g>
</a>
</g>
</a>
</g>
</g>
<!-- PEGParser&#45;&gt;Parser -->
<g id="edge1" class="edge">
<title>PEGParser&#45;&gt;Parser</title>
<path fill="none" stroke="black" d="M60.69,-143.25C68.54,-169.33 79.52,-205.79 89.39,-238.58"/>
<polygon fill="none" stroke="black" points="86.02,-239.53 92.25,-248.09 92.72,-237.51 86.02,-239.53"/>
</g>
<!-- EarleyParser -->
<g id="node3" class="node">
<title>EarleyParser</title>
<g id="a_node3"><a xlink:href="#" xlink:title="class EarleyParser:&#10;Earley Parser. This parser can parse any context&#45;free grammar.">
<polygon fill="none" stroke="black" points="118,-0.5 118,-213 236,-213 236,-0.5 118,-0.5"/>
<text text-anchor="start" x="138" y="-196.7" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">EarleyParser</text>
<polyline fill="none" stroke="black" points="118,-187 236,-187"/>
<g id="a_node3_13"><a xlink:href="#" xlink:title="EarleyParser">
<g id="a_node3_14"><a xlink:href="#" xlink:title="__init__(self, grammar, **kwargs):&#10;Constructor.&#10;`grammar` is the grammar to be used for parsing.&#10;Keyword arguments:&#10;`start_symbol` is the start symbol (default: &#39;&lt;start&gt;&#39;).&#10;`log` enables logging (default: False).&#10;`coalesce` defines if tokens should be coalesced (default: True).&#10;`tokens`, if set, is a set of tokens to be used.">
<text text-anchor="start" x="126" y="-174.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="10.00">__init__()</text>
</a>
</g>
<g id="a_node3_15"><a xlink:href="#" xlink:title="chart_parse(self, words, start)">
<text text-anchor="start" x="126" y="-160.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">chart_parse()</text>
</a>
</g>
<g id="a_node3_16"><a xlink:href="#" xlink:title="complete(self, col, state)">
<text text-anchor="start" x="126" y="-148" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">complete()</text>
</a>
</g>
<g id="a_node3_17"><a xlink:href="#" xlink:title="earley_complete(self, col, state)">
<text text-anchor="start" x="126" y="-135.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">earley_complete()</text>
</a>
</g>
<g id="a_node3_18"><a xlink:href="#" xlink:title="extract_a_tree(self, forest_node)">
<text text-anchor="start" x="126" y="-122.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">extract_a_tree()</text>
</a>
</g>
<g id="a_node3_19"><a xlink:href="#" xlink:title="extract_trees(self, forest_node)">
<text text-anchor="start" x="126" y="-109.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">extract_trees()</text>
</a>
</g>
<g id="a_node3_20"><a xlink:href="#" xlink:title="fill_chart(self, chart)">
<text text-anchor="start" x="126" y="-97" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">fill_chart()</text>
</a>
</g>
<g id="a_node3_21"><a xlink:href="#" xlink:title="forest(self, s, kind, chart)">
<text text-anchor="start" x="126" y="-84.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">forest()</text>
</a>
</g>
<g id="a_node3_22"><a xlink:href="#" xlink:title="parse(self, text):&#10;Parse `text` using the grammar.&#10;Return an iterable of parse trees.">
<text text-anchor="start" x="126" y="-72.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="10.00">parse()</text>
</a>
</g>
<g id="a_node3_23"><a xlink:href="#" xlink:title="parse_forest(self, chart, state)">
<text text-anchor="start" x="126" y="-58.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">parse_forest()</text>
</a>
</g>
<g id="a_node3_24"><a xlink:href="#" xlink:title="parse_paths(self, named_expr, chart, frm, til)">
<text text-anchor="start" x="126" y="-46" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">parse_paths()</text>
</a>
</g>
<g id="a_node3_25"><a xlink:href="#" xlink:title="parse_prefix(self, text):&#10;Return pair (cursor, forest) for longest prefix of text.&#10;To be defined in subclasses.">
<text text-anchor="start" x="126" y="-34.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="10.00">parse_prefix()</text>
</a>
</g>
<g id="a_node3_26"><a xlink:href="#" xlink:title="predict(self, col, sym, state)">
<text text-anchor="start" x="126" y="-20.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">predict()</text>
</a>
</g>
<g id="a_node3_27"><a xlink:href="#" xlink:title="scan(self, col, state, letter)">
<text text-anchor="start" x="126" y="-7.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">scan()</text>
</a>
</g>
</a>
</g>
</a>
</g>
</g>
<!-- EarleyParser&#45;&gt;Parser -->
<g id="edge2" class="edge">
<title>EarleyParser&#45;&gt;Parser</title>
<path fill="none" stroke="black" d="M144.72,-213.29C142.08,-221.91 139.45,-230.52 136.89,-238.88"/>
<polygon fill="none" stroke="black" points="133.6,-237.69 134.02,-248.28 140.29,-239.74 133.6,-237.69"/>
</g>
<!-- Legend -->
<g id="node4" class="node">
<title>Legend</title>
<text text-anchor="start" x="254.38" y="-122.75" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="10.00" fill="#b03a2e">Legend</text>
<text text-anchor="start" x="254.38" y="-112.75" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
<text text-anchor="start" x="260.38" y="-112.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="8.00">public_method()</text>
<text text-anchor="start" x="254.38" y="-102.75" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
<text text-anchor="start" x="260.38" y="-102.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text>
<text text-anchor="start" x="254.38" y="-92.75" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
<text text-anchor="start" x="260.38" y="-92.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
<text text-anchor="start" x="254.38" y="-83.7" font-family="Helvetica,sans-Serif" font-size="9.00">Hover over names to see doc</text>
</g>
</g>
</svg>
</div></div>
</div>
</section>
<section id="lessons-learned">
<h2>Lessons Learned<a class="headerlink" href="#lessons-learned" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>Grammars can be used to generate derivation trees for a given string.</p></li>
<li><p>Parsing Expression Grammars are intuitive, and easy to implement, but require care to write.</p></li>
<li><p>Earley Parsers can parse arbitrary Context Free Grammars.</p></li>
</ul>
</section>
<section id="next-steps">
<h2>Next Steps<a class="headerlink" href="#next-steps" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>Use parsed inputs to <a class="reference internal" href="LangFuzzer.html"><span class="std std-doc">recombine existing inputs</span></a></p></li>
</ul>
</section>
<section id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Link to this heading">#</a></h2>
<section id="exercise-1-an-alternative-packrat">
<h3>Exercise 1: An Alternative Packrat<a class="headerlink" href="#exercise-1-an-alternative-packrat" title="Link to this heading">#</a></h3>
<p>In the <em>Packrat</em> parser, we showed how one could implement a simple <em>PEG</em> parser. That parser kept track of the current location in the text using an index. Can you modify the parser so that it simply uses the current substring rather than tracking the index? That is, it should no longer have the <code class="docutils literal notranslate"><span class="pre">at</span></code> parameter.</p>
<p><strong>Solution.</strong>  Here is a possible solution:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PackratParser</span><span class="p">(</span><span class="n">Parser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">parse_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="n">txt</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unify_key</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_symbol</span><span class="p">(),</span> <span class="n">text</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">txt</span><span class="p">),</span> <span class="p">[</span><span class="n">res</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="n">remain</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_prefix</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">remain</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s2">&quot;at &quot;</span> <span class="o">+</span> <span class="n">res</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">unify_rule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">rule</span><span class="p">:</span>
            <span class="n">text</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unify_key</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">text</span><span class="p">,</span> <span class="kc">None</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">text</span><span class="p">,</span> <span class="n">results</span>

    <span class="k">def</span> <span class="nf">unify_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cgrammar</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">text</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">text</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">):],</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">text</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cgrammar</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
            <span class="n">text_</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unify_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">res</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">text_</span><span class="p">,</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">res</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">text</span><span class="p">,</span> <span class="kc">None</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s2">&quot;1 + (2 * 3)&quot;</span>
<span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">PackratParser</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="n">mystring</span>
    <span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="exercise-2-more-peg-syntax">
<h3>Exercise 2: More PEG Syntax<a class="headerlink" href="#exercise-2-more-peg-syntax" title="Link to this heading">#</a></h3>
<p>The <em>PEG</em> syntax provides a few notational conveniences reminiscent of regular expressions. For example, it supports the following operators (letters <code class="docutils literal notranslate"><span class="pre">T</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code> represents tokens that can be either terminal or nonterminal. <code class="docutils literal notranslate"><span class="pre">ε</span></code> is an empty string, and <code class="docutils literal notranslate"><span class="pre">/</span></code> is the ordered choice operator similar to the non-ordered choice operator <code class="docutils literal notranslate"><span class="pre">|</span></code>):</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T?</span></code> represents an optional greedy match of T and <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">:=</span> <span class="pre">T?</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">:=</span> <span class="pre">T/ε</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T*</span></code> represents zero or more greedy matches of <code class="docutils literal notranslate"><span class="pre">T</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">:=</span> <span class="pre">T*</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">:=</span> <span class="pre">T</span> <span class="pre">A/ε</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T+</span></code> represents one or more greedy matches – equivalent to <code class="docutils literal notranslate"><span class="pre">TT*</span></code></p></li>
</ul>
<p>If you look at the three notations above, each can be represented in the grammar in terms of basic syntax.
Remember the exercise from <a class="reference internal" href="Grammars.html"><span class="std std-doc">the chapter on grammars</span></a> that developed <code class="docutils literal notranslate"><span class="pre">define_ex_grammar()</span></code> that can represent grammars as Python code? extend <code class="docutils literal notranslate"><span class="pre">define_ex_grammar()</span></code> to <code class="docutils literal notranslate"><span class="pre">define_peg()</span></code> to support the above notational conveniences. The decorator should rewrite a given grammar that contains these notations to an equivalent grammar in basic syntax.</p>
</section>
<section id="exercise-3-peg-predicates">
<h3>Exercise 3: PEG Predicates<a class="headerlink" href="#exercise-3-peg-predicates" title="Link to this heading">#</a></h3>
<p>Beyond these notational conveniences, it also supports two predicates that can provide a powerful lookahead facility that does not consume any input.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T&amp;A</span></code> represents an <em>And-predicate</em> that matches <code class="docutils literal notranslate"><span class="pre">T</span></code> if <code class="docutils literal notranslate"><span class="pre">T</span></code> is matched, and it is immediately followed by <code class="docutils literal notranslate"><span class="pre">A</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T!A</span></code> represents a <em>Not-predicate</em> that matches <code class="docutils literal notranslate"><span class="pre">T</span></code> if <code class="docutils literal notranslate"><span class="pre">T</span></code> is matched, and it is <em>not</em> immediately followed by <code class="docutils literal notranslate"><span class="pre">A</span></code></p></li>
</ul>
<p>Implement these predicates in our <em>PEG</em> parser.</p>
</section>
<section id="exercise-4-earley-fill-chart">
<h3>Exercise 4: Earley Fill Chart<a class="headerlink" href="#exercise-4-earley-fill-chart" title="Link to this heading">#</a></h3>
<p>In the <code class="docutils literal notranslate"><span class="pre">Earley</span> <span class="pre">Parser</span></code>, <code class="docutils literal notranslate"><span class="pre">Column</span></code> class, we keep the states both as a <code class="docutils literal notranslate"><span class="pre">list</span></code> and also as a <code class="docutils literal notranslate"><span class="pre">dict</span></code> even though <code class="docutils literal notranslate"><span class="pre">dict</span></code> is ordered. Can you explain why?</p>
<p><strong>Hint</strong>: see the <code class="docutils literal notranslate"><span class="pre">fill_chart</span></code> method.</p>
<p><strong>Solution.</strong> Python allows us to append to a list in flight, while a dict, even though it is ordered does not allow that facility.</p>
<p>That is, the following will work</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
   <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>However, the following will result in an error</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">values</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span>
<span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
    <span class="n">values</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">*</span><span class="mi">2</span>
</pre></div>
</div>
<p>In the <code class="docutils literal notranslate"><span class="pre">fill_chart</span></code>, we make use of this facility to modify the set of states we are iterating on, on the fly.</p>
</section>
<section id="exercise-5-leo-parser">
<h3>Exercise 5: Leo Parser<a class="headerlink" href="#exercise-5-leo-parser" title="Link to this heading">#</a></h3>
<p>One of the problems with the original Earley parser is that while it can parse strings using arbitrary <em>Context Free Gramamrs</em>, its performance on right-recursive grammars is quadratic. That is, it takes <span class="math notranslate nohighlight">\(O(n^2)\)</span> runtime and space for parsing with right-recursive grammars. For example, consider the parsing of the following string by two different grammars <code class="docutils literal notranslate"><span class="pre">LR_GRAMMAR</span></code> and <code class="docutils literal notranslate"><span class="pre">RR_GRAMMAR</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s1">&#39;aaaaaa&#39;</span>
</pre></div>
</div>
</div>
</div>
<p>To see the problem, we need to enable logging. Here is the logged version of parsing with the <code class="docutils literal notranslate"><span class="pre">LR_GRAMMAR</span></code></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">EarleyParser</span><span class="p">(</span><span class="n">LR_GRAMMAR</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring</span><span class="p">)</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span> <span class="k">pass</span> <span class="c1"># consume the generator so that we can see the logs</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>None chart[0]
&lt;A&gt;:= |(0,0)
&lt;start&gt;:= &lt;A&gt; |(0,0) 

a chart[1]
&lt;A&gt;:= &lt;A&gt; a |(0,1)
&lt;start&gt;:= &lt;A&gt; |(0,1) 

a chart[2]
&lt;A&gt;:= &lt;A&gt; a |(0,2)
&lt;start&gt;:= &lt;A&gt; |(0,2) 

a chart[3]
&lt;A&gt;:= &lt;A&gt; a |(0,3)
&lt;start&gt;:= &lt;A&gt; |(0,3) 

a chart[4]
&lt;A&gt;:= &lt;A&gt; a |(0,4)
&lt;start&gt;:= &lt;A&gt; |(0,4) 

a chart[5]
&lt;A&gt;:= &lt;A&gt; a |(0,5)
&lt;start&gt;:= &lt;A&gt; |(0,5) 

a chart[6]
&lt;A&gt;:= &lt;A&gt; a |(0,6)
&lt;start&gt;:= &lt;A&gt; |(0,6) 
</pre></div>
</div>
</div>
</div>
<p>Compare that to the parsing of <code class="docutils literal notranslate"><span class="pre">RR_GRAMMAR</span></code> as seen below:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">EarleyParser</span><span class="p">(</span><span class="n">RR_GRAMMAR</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring</span><span class="p">)</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span> <span class="k">pass</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>None chart[0]
&lt;A&gt;:= |(0,0)
&lt;start&gt;:= &lt;A&gt; |(0,0) 

a chart[1]
&lt;A&gt;:= |(1,1)
&lt;A&gt;:= a &lt;A&gt; |(0,1)
&lt;start&gt;:= &lt;A&gt; |(0,1) 

a chart[2]
&lt;A&gt;:= |(2,2)
&lt;A&gt;:= a &lt;A&gt; |(1,2)
&lt;A&gt;:= a &lt;A&gt; |(0,2)
&lt;start&gt;:= &lt;A&gt; |(0,2) 

a chart[3]
&lt;A&gt;:= |(3,3)
&lt;A&gt;:= a &lt;A&gt; |(2,3)
&lt;A&gt;:= a &lt;A&gt; |(1,3)
&lt;A&gt;:= a &lt;A&gt; |(0,3)
&lt;start&gt;:= &lt;A&gt; |(0,3) 

a chart[4]
&lt;A&gt;:= |(4,4)
&lt;A&gt;:= a &lt;A&gt; |(3,4)
&lt;A&gt;:= a &lt;A&gt; |(2,4)
&lt;A&gt;:= a &lt;A&gt; |(1,4)
&lt;A&gt;:= a &lt;A&gt; |(0,4)
&lt;start&gt;:= &lt;A&gt; |(0,4) 

a chart[5]
&lt;A&gt;:= |(5,5)
&lt;A&gt;:= a &lt;A&gt; |(4,5)
&lt;A&gt;:= a &lt;A&gt; |(3,5)
&lt;A&gt;:= a &lt;A&gt; |(2,5)
&lt;A&gt;:= a &lt;A&gt; |(1,5)
&lt;A&gt;:= a &lt;A&gt; |(0,5)
&lt;start&gt;:= &lt;A&gt; |(0,5) 

a chart[6]
&lt;A&gt;:= |(6,6)
&lt;A&gt;:= a &lt;A&gt; |(5,6)
&lt;A&gt;:= a &lt;A&gt; |(4,6)
&lt;A&gt;:= a &lt;A&gt; |(3,6)
&lt;A&gt;:= a &lt;A&gt; |(2,6)
&lt;A&gt;:= a &lt;A&gt; |(1,6)
&lt;A&gt;:= a &lt;A&gt; |(0,6)
&lt;start&gt;:= &lt;A&gt; |(0,6) 
</pre></div>
</div>
</div>
</div>
<p>As can be seen from the parsing log for each letter, the number of states with representation <code class="docutils literal notranslate"><span class="pre">&lt;A&gt;:</span> <span class="pre">a</span> <span class="pre">&lt;A&gt;</span> <span class="pre">●</span> <span class="pre">(i,</span> <span class="pre">j)</span></code> increases at each stage, and these are simply a left over from the previous letter. They do not contribute anything more to the parse other than to simply complete these entries. However, they take up space, and require resources for inspection, contributing a factor of <code class="docutils literal notranslate"><span class="pre">n</span></code> in analysis.</p>
<p>Joop Leo \cite{Leo1991} found that this inefficiency can be avoided by detecting right recursion. The idea is that before starting the <code class="docutils literal notranslate"><span class="pre">completion</span></code> step, check whether the current item has a <em>deterministic reduction path</em>. If such a path exists, add a copy of the topmost element of the <em>deteministic reduction path</em> to the current column, and return. If not, perform the original <code class="docutils literal notranslate"><span class="pre">completion</span></code> step.</p>
<p><strong>Definition 2.1</strong>: An item is said to be on the deterministic reduction path above <span class="math notranslate nohighlight">\([A \rightarrow  \gamma., i]\)</span> if it is <span class="math notranslate nohighlight">\([B \rightarrow \alpha A ., k]\)</span> with <span class="math notranslate nohighlight">\([B \rightarrow \alpha . A, k]\)</span> being the only item in <span class="math notranslate nohighlight">\( I_i \)</span> with the dot in front of A, or if it is on the deterministic reduction path above <span class="math notranslate nohighlight">\([B \rightarrow \alpha A ., k]\)</span>. An item on such a path is called <em>topmost</em> one if there is no item on the deterministic reduction path above it\cite{Leo1991}.</p>
<p>Finding a <em>deterministic reduction path</em> is as follows:</p>
<p>Given a complete state, represented by <code class="docutils literal notranslate"><span class="pre">&lt;A&gt;</span> <span class="pre">:</span> <span class="pre">seq_1</span> <span class="pre">●</span> <span class="pre">(s,</span> <span class="pre">e)</span></code> where <code class="docutils literal notranslate"><span class="pre">s</span></code> is the starting column for this rule, and <code class="docutils literal notranslate"><span class="pre">e</span></code> the current column, there is a <em>deterministic reduction path</em> <strong>above</strong> it if two constraints are satisfied.</p>
<ol class="arabic simple">
<li><p>There exist a <em>single</em> item in the form <code class="docutils literal notranslate"><span class="pre">&lt;B&gt;</span> <span class="pre">:</span> <span class="pre">seq_2</span> <span class="pre">●</span> <span class="pre">&lt;A&gt;</span> <span class="pre">(k,</span> <span class="pre">s)</span></code> in column <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p></li>
<li><p>That should be the <em>single</em> item in s with dot in front of <code class="docutils literal notranslate"><span class="pre">&lt;A&gt;</span></code></p></li>
</ol>
<p>The resulting item is of the form <code class="docutils literal notranslate"><span class="pre">&lt;B&gt;</span> <span class="pre">:</span> <span class="pre">seq_2</span> <span class="pre">&lt;A&gt;</span> <span class="pre">●</span> <span class="pre">(k,</span> <span class="pre">e)</span></code>, which is simply item from (1) advanced, and is considered above <code class="docutils literal notranslate"><span class="pre">&lt;A&gt;:..</span> <span class="pre">(s,</span> <span class="pre">e)</span></code> in the deterministic reduction path.
The <code class="docutils literal notranslate"><span class="pre">seq_1</span></code> and <code class="docutils literal notranslate"><span class="pre">seq_2</span></code> are arbitrary symbol sequences.</p>
<p>This forms the following chain of links, with <code class="docutils literal notranslate"><span class="pre">&lt;A&gt;:..</span> <span class="pre">(s_1,</span> <span class="pre">e)</span></code> being the child of <code class="docutils literal notranslate"><span class="pre">&lt;B&gt;:..</span> <span class="pre">(s_2,</span> <span class="pre">e)</span></code> etc.</p>
<p>Here is one way to visualize the chain:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;C&gt; : seq_3 &lt;B&gt; ● (s_3, e)  
             |  constraints satisfied by &lt;C&gt; : seq_3 ● &lt;B&gt; (s_3, s_2)
            &lt;B&gt; : seq_2 &lt;A&gt; ● (s_2, e)  
                         | constraints satisfied by &lt;B&gt; : seq_2 ● &lt;A&gt; (s_2, s_1)
                        &lt;A&gt; : seq_1 ● (s_1, e)
</pre></div>
</div>
<p>Essentially, what we want to do is to identify potential deterministic right recursion candidates, perform completion on them, and <em>throw away the result</em>. We do this until we reach the top. See Grune et al.~\cite{grune2008parsing} for further information.</p>
<p>Note that the completions are in the same column (<code class="docutils literal notranslate"><span class="pre">e</span></code>), with each candidate with constraints satisfied
in further and further earlier columns (as shown below):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;C&gt; : seq_3 ● &lt;B&gt; (s_3, s_2)  --&gt;              &lt;C&gt; : seq_3 &lt;B&gt; ● (s_3, e)
               |
              &lt;B&gt; : seq_2 ● &lt;A&gt; (s_2, s_1) --&gt; &lt;B&gt; : seq_2 &lt;A&gt; ● (s_2, e)  
                             |
                            &lt;A&gt; : seq_1 ●                        (s_1, e)
</pre></div>
</div>
<p>Following this chain, the topmost item is the item <code class="docutils literal notranslate"><span class="pre">&lt;C&gt;:..</span> <span class="pre">(s_3,</span> <span class="pre">e)</span></code> that does not have a parent. The topmost item needs to be saved is called a <em>transitive</em> item by Leo, and it is associated with the non-terminal symbol that started the lookup. The transitive item needs to be added to each column we inspect.</p>
<p>Here is the skeleton for the parser <code class="docutils literal notranslate"><span class="pre">LeoParser</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LeoParser</span><span class="p">(</span><span class="n">EarleyParser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">complete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">leo_complete</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">leo_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">detred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deterministic_reduction</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">detred</span><span class="p">:</span>
            <span class="n">col</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">detred</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">earley_complete</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deterministic_reduction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</pre></div>
</div>
</div>
</div>
<p>Can you implement the <code class="docutils literal notranslate"><span class="pre">deterministic_reduction()</span></code> method to obtain the topmost element?</p>
<p><strong>Solution.</strong>  Here is a possible solution:</p>
<p>First, we update our <code class="docutils literal notranslate"><span class="pre">Column</span></code> class with the ability to add transitive items. Note that, while Leo asks the transitive to be added to the set <span class="math notranslate nohighlight">\( I_k \)</span> there is no actual requirement for the transitive states to be added to the <code class="docutils literal notranslate"><span class="pre">states</span></code> list. The transitive items are only intended for memoization and not for the <code class="docutils literal notranslate"><span class="pre">fill_chart()</span></code> method. Hence, we track them separately.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Column</span><span class="p">(</span><span class="n">Column</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">letter</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">letter</span> <span class="o">=</span> <span class="n">index</span><span class="p">,</span> <span class="n">letter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unique</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitives</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">{},</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">add_transitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitives</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitives</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitives</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Remember the picture we drew of the deterministic path?</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    &lt;C&gt; : seq_3 &lt;B&gt; ● (s_3, e)  
                 |  constraints satisfied by &lt;C&gt; : seq_3 ● &lt;B&gt; (s_3, s_2)
                &lt;B&gt; : seq_2 &lt;A&gt; ● (s_2, e)  
                             | constraints satisfied by &lt;B&gt; : seq_2 ● &lt;A&gt; (s_2, s_1)
                            &lt;A&gt; : seq_1 ● (s_1, e)
</pre></div>
</div>
<p>We define a function <code class="docutils literal notranslate"><span class="pre">uniq_postdot()</span></code> that given the item <code class="docutils literal notranslate"><span class="pre">&lt;A&gt;</span> <span class="pre">:=</span> <span class="pre">seq_1</span> <span class="pre">●</span> <span class="pre">(s_1,</span> <span class="pre">e)</span></code>, returns a <code class="docutils literal notranslate"><span class="pre">&lt;B&gt;</span> <span class="pre">:</span> <span class="pre">seq_2</span> <span class="pre">●</span> <span class="pre">&lt;A&gt;</span> <span class="pre">(s_2,</span> <span class="pre">s_1)</span></code> that satisfies the constraints mentioned in the above picture.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LeoParser</span><span class="p">(</span><span class="n">LeoParser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">uniq_postdot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">st_A</span><span class="p">):</span>
        <span class="n">col_s1</span> <span class="o">=</span> <span class="n">st_A</span><span class="o">.</span><span class="n">s_col</span>
        <span class="n">parent_states</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">col_s1</span><span class="o">.</span><span class="n">states</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">expr</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">at_dot</span><span class="p">()</span> <span class="o">==</span> <span class="n">st_A</span><span class="o">.</span><span class="n">name</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent_states</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">matching_st_B</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">parent_states</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">dot</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">matching_st_B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">matching_st_B</span> <span class="k">else</span> <span class="kc">None</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">lp</span> <span class="o">=</span> <span class="n">LeoParser</span><span class="p">(</span><span class="n">RR_GRAMMAR</span><span class="p">)</span>
<span class="p">[(</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">uniq_postdot</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">states</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[(&#39;&lt;D&gt;:= d |(3,4)&#39;, &#39;&lt;B&gt;:= | &lt;D&gt;(3,3)&#39;),
 (&#39;&lt;B&gt;:= &lt;D&gt; |(3,4)&#39;, &#39;&lt;start&gt;:= &lt;A&gt; | &lt;B&gt;(0,3)&#39;),
 (&#39;&lt;start&gt;:= &lt;A&gt; &lt;B&gt; |(0,4)&#39;, &#39;None&#39;)]
</pre></div>
</div>
</div>
</div>
<p>We next define the function <code class="docutils literal notranslate"><span class="pre">get_top()</span></code> that is the core of deterministic reduction which gets the topmost state above the current state (<code class="docutils literal notranslate"><span class="pre">A</span></code>).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LeoParser</span><span class="p">(</span><span class="n">LeoParser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get_top</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_A</span><span class="p">):</span>
        <span class="n">st_B_inc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uniq_postdot</span><span class="p">(</span><span class="n">state_A</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">st_B_inc</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        
        <span class="n">t_name</span> <span class="o">=</span> <span class="n">st_B_inc</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">t_name</span> <span class="ow">in</span> <span class="n">st_B_inc</span><span class="o">.</span><span class="n">e_col</span><span class="o">.</span><span class="n">transitives</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">st_B_inc</span><span class="o">.</span><span class="n">e_col</span><span class="o">.</span><span class="n">transitives</span><span class="p">[</span><span class="n">t_name</span><span class="p">]</span>

        <span class="n">st_B</span> <span class="o">=</span> <span class="n">st_B_inc</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>

        <span class="n">top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_top</span><span class="p">(</span><span class="n">st_B</span><span class="p">)</span> <span class="ow">or</span> <span class="n">st_B</span>
        <span class="k">return</span> <span class="n">st_B_inc</span><span class="o">.</span><span class="n">e_col</span><span class="o">.</span><span class="n">add_transitive</span><span class="p">(</span><span class="n">t_name</span><span class="p">,</span> <span class="n">top</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Once we have the machinery in place, <code class="docutils literal notranslate"><span class="pre">deterministic_reduction()</span></code> itself is simply a wrapper to call <code class="docutils literal notranslate"><span class="pre">get_top()</span></code></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LeoParser</span><span class="p">(</span><span class="n">LeoParser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">deterministic_reduction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_top</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">lp</span> <span class="o">=</span> <span class="n">LeoParser</span><span class="p">(</span><span class="n">RR_GRAMMAR</span><span class="p">)</span>
<span class="n">columns</span> <span class="o">=</span> <span class="n">lp</span><span class="o">.</span><span class="n">chart_parse</span><span class="p">(</span><span class="n">mystring</span><span class="p">,</span> <span class="n">lp</span><span class="o">.</span><span class="n">start_symbol</span><span class="p">())</span>
<span class="p">[(</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">get_top</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">states</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[(&#39;&lt;A&gt;:= a | &lt;A&gt;(5,6)&#39;, &#39;&lt;start&gt;:= &lt;A&gt; |(0,-1)&#39;),
 (&#39;&lt;A&gt;:= | a &lt;A&gt;(6,6)&#39;, &#39;&lt;start&gt;:= &lt;A&gt; |(0,-1)&#39;),
 (&#39;&lt;A&gt;:= |(6,6)&#39;, &#39;&lt;start&gt;:= &lt;A&gt; |(0,-1)&#39;),
 (&#39;&lt;A&gt;:= a &lt;A&gt; |(5,6)&#39;, &#39;&lt;start&gt;:= &lt;A&gt; |(0,-1)&#39;),
 (&#39;&lt;start&gt;:= &lt;A&gt; |(0,6)&#39;, &#39;None&#39;)]
</pre></div>
</div>
</div>
</div>
<p>Now, both LR and RR grammars should work within <span class="math notranslate nohighlight">\(O(n)\)</span> bounds.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">LeoParser</span><span class="p">(</span><span class="n">RR_GRAMMAR</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring</span><span class="p">)</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span> <span class="k">pass</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>None chart[0]
&lt;A&gt;:= |(0,0)
&lt;start&gt;:= &lt;A&gt; |(0,0) 

a chart[1]
&lt;A&gt;:= |(1,1)
&lt;A&gt;:= a &lt;A&gt; |(0,1)
&lt;start&gt;:= &lt;A&gt; |(0,1) 

a chart[2]
&lt;A&gt;:= |(2,2)
&lt;A&gt;:= a &lt;A&gt; |(1,2)
&lt;start&gt;:= &lt;A&gt; |(0,2) 

a chart[3]
&lt;A&gt;:= |(3,3)
&lt;A&gt;:= a &lt;A&gt; |(2,3)
&lt;start&gt;:= &lt;A&gt; |(0,3) 

a chart[4]
&lt;A&gt;:= |(4,4)
&lt;A&gt;:= a &lt;A&gt; |(3,4)
&lt;start&gt;:= &lt;A&gt; |(0,4) 

a chart[5]
&lt;A&gt;:= |(5,5)
&lt;A&gt;:= a &lt;A&gt; |(4,5)
&lt;start&gt;:= &lt;A&gt; |(0,5) 

a chart[6]
&lt;A&gt;:= |(6,6)
&lt;A&gt;:= a &lt;A&gt; |(5,6)
&lt;start&gt;:= &lt;A&gt; |(0,6) 
</pre></div>
</div>
</div>
</div>
<p>We verify the Leo parser with a few more right recursive grammars.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">RR_GRAMMAR2</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;ab&lt;A&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">],</span>
<span class="p">}</span>
<span class="n">mystring2</span> <span class="o">=</span> <span class="s1">&#39;ababababab&#39;</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">LeoParser</span><span class="p">(</span><span class="n">RR_GRAMMAR2</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring2</span><span class="p">)</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span> <span class="k">pass</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>None chart[0]
&lt;A&gt;:= |(0,0)
&lt;start&gt;:= &lt;A&gt; |(0,0) 

a chart[1]
 

b chart[2]
&lt;A&gt;:= |(2,2)
&lt;A&gt;:= a b &lt;A&gt; |(0,2)
&lt;start&gt;:= &lt;A&gt; |(0,2) 

a chart[3]
 

b chart[4]
&lt;A&gt;:= |(4,4)
&lt;A&gt;:= a b &lt;A&gt; |(2,4)
&lt;start&gt;:= &lt;A&gt; |(0,4) 

a chart[5]
 

b chart[6]
&lt;A&gt;:= |(6,6)
&lt;A&gt;:= a b &lt;A&gt; |(4,6)
&lt;start&gt;:= &lt;A&gt; |(0,6) 

a chart[7]
 

b chart[8]
&lt;A&gt;:= |(8,8)
&lt;A&gt;:= a b &lt;A&gt; |(6,8)
&lt;start&gt;:= &lt;A&gt; |(0,8) 

a chart[9]
 

b chart[10]
&lt;A&gt;:= |(10,10)
&lt;A&gt;:= a b &lt;A&gt; |(8,10)
&lt;start&gt;:= &lt;A&gt; |(0,10) 
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">RR_GRAMMAR3</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;c&lt;A&gt;&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;ab&lt;A&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">],</span>
<span class="p">}</span>
<span class="n">mystring3</span> <span class="o">=</span> <span class="s1">&#39;cababababab&#39;</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">LeoParser</span><span class="p">(</span><span class="n">RR_GRAMMAR3</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring3</span><span class="p">)</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span> <span class="k">pass</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>None chart[0]
 

c chart[1]
&lt;A&gt;:= |(1,1)
&lt;start&gt;:= c &lt;A&gt; |(0,1) 

a chart[2]
 

b chart[3]
&lt;A&gt;:= |(3,3)
&lt;A&gt;:= a b &lt;A&gt; |(1,3)
&lt;start&gt;:= c &lt;A&gt; |(0,3) 

a chart[4]
 

b chart[5]
&lt;A&gt;:= |(5,5)
&lt;A&gt;:= a b &lt;A&gt; |(3,5)
&lt;start&gt;:= c &lt;A&gt; |(0,5) 

a chart[6]
 

b chart[7]
&lt;A&gt;:= |(7,7)
&lt;A&gt;:= a b &lt;A&gt; |(5,7)
&lt;start&gt;:= c &lt;A&gt; |(0,7) 

a chart[8]
 

b chart[9]
&lt;A&gt;:= |(9,9)
&lt;A&gt;:= a b &lt;A&gt; |(7,9)
&lt;start&gt;:= c &lt;A&gt; |(0,9) 

a chart[10]
 

b chart[11]
&lt;A&gt;:= |(11,11)
&lt;A&gt;:= a b &lt;A&gt; |(9,11)
&lt;start&gt;:= c &lt;A&gt; |(0,11) 
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">RR_GRAMMAR4</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;A&gt;c&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;ab&lt;A&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">],</span>
<span class="p">}</span>
<span class="n">mystring4</span> <span class="o">=</span> <span class="s1">&#39;ababababc&#39;</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">LeoParser</span><span class="p">(</span><span class="n">RR_GRAMMAR4</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring4</span><span class="p">)</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span> <span class="k">pass</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>None chart[0]
&lt;A&gt;:= |(0,0) 

a chart[1]
 

b chart[2]
&lt;A&gt;:= |(2,2)
&lt;A&gt;:= a b &lt;A&gt; |(0,2) 

a chart[3]
 

b chart[4]
&lt;A&gt;:= |(4,4)
&lt;A&gt;:= a b &lt;A&gt; |(2,4)
&lt;A&gt;:= a b &lt;A&gt; |(0,4) 

a chart[5]
 

b chart[6]
&lt;A&gt;:= |(6,6)
&lt;A&gt;:= a b &lt;A&gt; |(4,6)
&lt;A&gt;:= a b &lt;A&gt; |(0,6) 

a chart[7]
 

b chart[8]
&lt;A&gt;:= |(8,8)
&lt;A&gt;:= a b &lt;A&gt; |(6,8)
&lt;A&gt;:= a b &lt;A&gt; |(0,8) 

c chart[9]
&lt;start&gt;:= &lt;A&gt; c |(0,9) 
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">RR_GRAMMAR5</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;ab&lt;B&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;B&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">],</span>
<span class="p">}</span>
<span class="n">mystring5</span> <span class="o">=</span> <span class="s1">&#39;abababab&#39;</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">LeoParser</span><span class="p">(</span><span class="n">RR_GRAMMAR5</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring5</span><span class="p">)</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span> <span class="k">pass</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>None chart[0]
&lt;A&gt;:= |(0,0)
&lt;start&gt;:= &lt;A&gt; |(0,0) 

a chart[1]
 

b chart[2]
&lt;A&gt;:= a b &lt;B&gt; |(0,2)
&lt;A&gt;:= |(2,2)
&lt;B&gt;:= &lt;A&gt; |(2,2)
&lt;start&gt;:= &lt;A&gt; |(0,2) 

a chart[3]
 

b chart[4]
&lt;A&gt;:= a b &lt;B&gt; |(2,4)
&lt;A&gt;:= |(4,4)
&lt;B&gt;:= &lt;A&gt; |(4,4)
&lt;start&gt;:= &lt;A&gt; |(0,4) 

a chart[5]
 

b chart[6]
&lt;A&gt;:= a b &lt;B&gt; |(4,6)
&lt;A&gt;:= |(6,6)
&lt;B&gt;:= &lt;A&gt; |(6,6)
&lt;start&gt;:= &lt;A&gt; |(0,6) 

a chart[7]
 

b chart[8]
&lt;A&gt;:= a b &lt;B&gt; |(6,8)
&lt;A&gt;:= |(8,8)
&lt;B&gt;:= &lt;A&gt; |(8,8)
&lt;start&gt;:= &lt;A&gt; |(0,8) 
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">RR_GRAMMAR6</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&lt;B&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;B&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;b&lt;A&gt;&#39;</span><span class="p">],</span>
<span class="p">}</span>
<span class="n">mystring6</span> <span class="o">=</span> <span class="s1">&#39;abababab&#39;</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">LeoParser</span><span class="p">(</span><span class="n">RR_GRAMMAR6</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring6</span><span class="p">)</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span> <span class="k">pass</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>None chart[0]
&lt;A&gt;:= |(0,0)
&lt;start&gt;:= &lt;A&gt; |(0,0) 

a chart[1]
 

b chart[2]
&lt;A&gt;:= |(2,2)
&lt;B&gt;:= b &lt;A&gt; |(1,2)
&lt;start&gt;:= &lt;A&gt; |(0,2) 

a chart[3]
 

b chart[4]
&lt;A&gt;:= |(4,4)
&lt;B&gt;:= b &lt;A&gt; |(3,4)
&lt;start&gt;:= &lt;A&gt; |(0,4) 

a chart[5]
 

b chart[6]
&lt;A&gt;:= |(6,6)
&lt;B&gt;:= b &lt;A&gt; |(5,6)
&lt;start&gt;:= &lt;A&gt; |(0,6) 

a chart[7]
 

b chart[8]
&lt;A&gt;:= |(8,8)
&lt;B&gt;:= b &lt;A&gt; |(7,8)
&lt;start&gt;:= &lt;A&gt; |(0,8) 
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">RR_GRAMMAR7</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&lt;A&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">],</span>
<span class="p">}</span>
<span class="n">mystring7</span> <span class="o">=</span> <span class="s1">&#39;aaaaaaaa&#39;</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">LeoParser</span><span class="p">(</span><span class="n">RR_GRAMMAR7</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring7</span><span class="p">)</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span> <span class="k">pass</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>None chart[0]
 

a chart[1]
&lt;A&gt;:= a |(0,1)
&lt;start&gt;:= &lt;A&gt; |(0,1) 

a chart[2]
&lt;A&gt;:= a |(1,2)
&lt;start&gt;:= &lt;A&gt; |(0,2) 

a chart[3]
&lt;A&gt;:= a |(2,3)
&lt;start&gt;:= &lt;A&gt; |(0,3) 

a chart[4]
&lt;A&gt;:= a |(3,4)
&lt;start&gt;:= &lt;A&gt; |(0,4) 

a chart[5]
&lt;A&gt;:= a |(4,5)
&lt;start&gt;:= &lt;A&gt; |(0,5) 

a chart[6]
&lt;A&gt;:= a |(5,6)
&lt;start&gt;:= &lt;A&gt; |(0,6) 

a chart[7]
&lt;A&gt;:= a |(6,7)
&lt;start&gt;:= &lt;A&gt; |(0,7) 

a chart[8]
&lt;A&gt;:= a |(7,8)
&lt;start&gt;:= &lt;A&gt; |(0,8) 
</pre></div>
</div>
</div>
</div>
<p>We verify that our parser works correctly on <code class="docutils literal notranslate"><span class="pre">LR_GRAMMAR</span></code> too.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">LeoParser</span><span class="p">(</span><span class="n">LR_GRAMMAR</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring</span><span class="p">)</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span> <span class="k">pass</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>None chart[0]
&lt;A&gt;:= |(0,0)
&lt;start&gt;:= &lt;A&gt; |(0,0) 

a chart[1]
&lt;A&gt;:= &lt;A&gt; a |(0,1)
&lt;start&gt;:= &lt;A&gt; |(0,1) 

a chart[2]
&lt;A&gt;:= &lt;A&gt; a |(0,2)
&lt;start&gt;:= &lt;A&gt; |(0,2) 

a chart[3]
&lt;A&gt;:= &lt;A&gt; a |(0,3)
&lt;start&gt;:= &lt;A&gt; |(0,3) 

a chart[4]
&lt;A&gt;:= &lt;A&gt; a |(0,4)
&lt;start&gt;:= &lt;A&gt; |(0,4) 

a chart[5]
&lt;A&gt;:= &lt;A&gt; a |(0,5)
&lt;start&gt;:= &lt;A&gt; |(0,5) 

a chart[6]
&lt;A&gt;:= &lt;A&gt; a |(0,6)
&lt;start&gt;:= &lt;A&gt; |(0,6) 
</pre></div>
</div>
</div>
</div>
<p><strong>Advanced:</strong> We have fixed the complexity bounds. However, because we are saving only the topmost item of a right recursion, we need to fix our parser to be aware of our fix while extracting parse trees. Can you fix it?</p>
<p><strong>Hint:</strong> Leo suggests simply transforming the Leo item sets to normal Earley sets, with the results from deterministic reduction expanded to their originals. For that, keep in mind the picture of constraint chain we drew earlier.</p>
<p><strong>Solution.</strong> Here is a possible solution.</p>
<p>We first change the definition of <code class="docutils literal notranslate"><span class="pre">add_transitive()</span></code>, so that results of deterministic reduction can be identified later.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Column</span><span class="p">(</span><span class="n">Column</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">add_transitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitives</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitives</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">TState</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span>
                                       <span class="n">state</span><span class="o">.</span><span class="n">s_col</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">e_col</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitives</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>We also need a <code class="docutils literal notranslate"><span class="pre">back()</span></code> method to create the constraints.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">State</span><span class="p">(</span><span class="n">State</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">back</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">e_col</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We update <code class="docutils literal notranslate"><span class="pre">copy()</span></code> to make <code class="docutils literal notranslate"><span class="pre">TState</span></code> items instead.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TState</span><span class="p">(</span><span class="n">State</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">e_col</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We now modify the <code class="docutils literal notranslate"><span class="pre">LeoParser</span></code> to keep track of the chain of constrains that we mentioned earlier.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LeoParser</span><span class="p">(</span><span class="n">LeoParser</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_postdots</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we update the <code class="docutils literal notranslate"><span class="pre">uniq_postdot()</span></code> so that it tracks the chain of links.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LeoParser</span><span class="p">(</span><span class="n">LeoParser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">uniq_postdot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">st_A</span><span class="p">):</span>
        <span class="n">col_s1</span> <span class="o">=</span> <span class="n">st_A</span><span class="o">.</span><span class="n">s_col</span>
        <span class="n">parent_states</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">col_s1</span><span class="o">.</span><span class="n">states</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">expr</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">at_dot</span><span class="p">()</span> <span class="o">==</span> <span class="n">st_A</span><span class="o">.</span><span class="n">name</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent_states</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">matching_st_B</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">parent_states</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">dot</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">matching_st_B</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_postdots</span><span class="p">[</span><span class="n">matching_st_B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_t</span><span class="p">()]</span> <span class="o">=</span> <span class="n">st_A</span>
            <span class="k">return</span> <span class="n">matching_st_B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">None</span>
      
</pre></div>
</div>
</div>
</div>
<p>We next define a method <code class="docutils literal notranslate"><span class="pre">expand_tstate()</span></code> that, when given a <code class="docutils literal notranslate"><span class="pre">TState</span></code>, generates all the intermediate links that we threw away earlier for a given end column.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LeoParser</span><span class="p">(</span><span class="n">LeoParser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">expand_tstate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">_t</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_postdots</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">c_C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_postdots</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">_t</span><span class="p">()]</span>
        <span class="n">e</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">c_C</span><span class="o">.</span><span class="n">advance</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expand_tstate</span><span class="p">(</span><span class="n">c_C</span><span class="o">.</span><span class="n">back</span><span class="p">(),</span> <span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We define a <code class="docutils literal notranslate"><span class="pre">rearrange()</span></code> method to generate a reversed table where each column contains states that start at that column.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LeoParser</span><span class="p">(</span><span class="n">LeoParser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">rearrange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="p">):</span>
        <span class="n">f_table</span> <span class="o">=</span> <span class="p">[</span><span class="n">Column</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">letter</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">table</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">table</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">col</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
                <span class="n">f_table</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">s_col</span><span class="o">.</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f_table</span>
</pre></div>
</div>
</div>
</div>
<p>Here is the rearranged table. (Can you explain why the Column 0 has numerous <code class="docutils literal notranslate"><span class="pre">&lt;start&gt;</span></code> items?)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ep</span> <span class="o">=</span> <span class="n">LeoParser</span><span class="p">(</span><span class="n">RR_GRAMMAR</span><span class="p">)</span>
<span class="n">columns</span> <span class="o">=</span> <span class="n">ep</span><span class="o">.</span><span class="n">chart_parse</span><span class="p">(</span><span class="n">mystring</span><span class="p">,</span> <span class="n">ep</span><span class="o">.</span><span class="n">start_symbol</span><span class="p">())</span>
<span class="n">r_table</span> <span class="o">=</span> <span class="n">ep</span><span class="o">.</span><span class="n">rearrange</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>
<span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">r_table</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>None chart[0]
&lt;A&gt;:= |(0,0)
&lt;start&gt;:= &lt;A&gt; |(0,0)
&lt;A&gt;:= a &lt;A&gt; |(0,1)
&lt;start&gt;:= &lt;A&gt; |(0,1)
&lt;start&gt;:= &lt;A&gt; |(0,2)
&lt;start&gt;:= &lt;A&gt; |(0,3)
&lt;start&gt;:= &lt;A&gt; |(0,4)
&lt;start&gt;:= &lt;A&gt; |(0,5)
&lt;start&gt;:= &lt;A&gt; |(0,6) 

a chart[1]
&lt;A&gt;:= |(1,1)
&lt;A&gt;:= a &lt;A&gt; |(1,2) 

a chart[2]
&lt;A&gt;:= |(2,2)
&lt;A&gt;:= a &lt;A&gt; |(2,3) 

a chart[3]
&lt;A&gt;:= |(3,3)
&lt;A&gt;:= a &lt;A&gt; |(3,4) 

a chart[4]
&lt;A&gt;:= |(4,4)
&lt;A&gt;:= a &lt;A&gt; |(4,5) 

a chart[5]
&lt;A&gt;:= |(5,5)
&lt;A&gt;:= a &lt;A&gt; |(5,6) 

a chart[6]
&lt;A&gt;:= |(6,6) 
</pre></div>
</div>
</div>
</div>
<p>We save the result of rearrange before going into <code class="docutils literal notranslate"><span class="pre">parse_forest()</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LeoParser</span><span class="p">(</span><span class="n">LeoParser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="n">cursor</span><span class="p">,</span> <span class="n">states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_prefix</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">states</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">finished</span><span class="p">()),</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cursor</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">start</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s2">&quot;at &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">cursor</span><span class="p">:]))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">r_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rearrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">)</span>
        <span class="n">forest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_trees</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parse_forest</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">,</span> <span class="n">start</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">forest</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">prune_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Finally, during <code class="docutils literal notranslate"><span class="pre">parse_forest()</span></code>, we first check to see if it is a transitive state, and if it is, expand it to the original sequence of states using <code class="docutils literal notranslate"><span class="pre">traverse_constraints()</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LeoParser</span><span class="p">(</span><span class="n">LeoParser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">parse_forest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">TState</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expand_tstate</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">back</span><span class="p">(),</span> <span class="n">state</span><span class="o">.</span><span class="n">e_col</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">parse_forest</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>This completes our implementation of <code class="docutils literal notranslate"><span class="pre">LeoParser</span></code>.</p>
<p>We check whether the previously defined right recursive grammars parse and return the correct parse trees.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">LeoParser</span><span class="p">(</span><span class="n">RR_GRAMMAR</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring</span><span class="p">)</span>
<span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
    <span class="k">assert</span> <span class="n">mystring</span> <span class="o">==</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">LeoParser</span><span class="p">(</span><span class="n">RR_GRAMMAR2</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring2</span><span class="p">)</span>
<span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
    <span class="k">assert</span> <span class="n">mystring2</span> <span class="o">==</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">LeoParser</span><span class="p">(</span><span class="n">RR_GRAMMAR3</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring3</span><span class="p">)</span>
<span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
    <span class="k">assert</span> <span class="n">mystring3</span> <span class="o">==</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">LeoParser</span><span class="p">(</span><span class="n">RR_GRAMMAR4</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring4</span><span class="p">)</span>
<span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
    <span class="k">assert</span> <span class="n">mystring4</span> <span class="o">==</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">LeoParser</span><span class="p">(</span><span class="n">RR_GRAMMAR5</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring5</span><span class="p">)</span>
<span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
    <span class="k">assert</span> <span class="n">mystring5</span> <span class="o">==</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">LeoParser</span><span class="p">(</span><span class="n">RR_GRAMMAR6</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring6</span><span class="p">)</span>
<span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
    <span class="k">assert</span> <span class="n">mystring6</span> <span class="o">==</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">LeoParser</span><span class="p">(</span><span class="n">RR_GRAMMAR7</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring7</span><span class="p">)</span>
<span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
    <span class="k">assert</span> <span class="n">mystring7</span> <span class="o">==</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">LeoParser</span><span class="p">(</span><span class="n">LR_GRAMMAR</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring</span><span class="p">)</span>
<span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
    <span class="k">assert</span> <span class="n">mystring</span> <span class="o">==</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">RR_GRAMMAR8</span> <span class="o">=</span> <span class="p">{</span>
   <span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">],</span>
   <span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&lt;A&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">]</span>
<span class="p">}</span>
<span class="n">mystring8</span> <span class="o">=</span> <span class="s1">&#39;aa&#39;</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">RR_GRAMMAR9</span> <span class="o">=</span> <span class="p">{</span>
   <span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">],</span>
   <span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;B&gt;&lt;A&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;B&gt;&#39;</span><span class="p">],</span>
   <span class="s1">&#39;&lt;B&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span>
<span class="p">}</span>
<span class="n">mystring9</span> <span class="o">=</span> <span class="s1">&#39;bbbbbbb&#39;</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">LeoParser</span><span class="p">(</span><span class="n">RR_GRAMMAR8</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring8</span><span class="p">)</span>
<span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)))</span>
    <span class="k">assert</span> <span class="n">mystring8</span> <span class="o">==</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;aa&#39;
&#39;aa&#39;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">LeoParser</span><span class="p">(</span><span class="n">RR_GRAMMAR9</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring9</span><span class="p">)</span>
<span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)))</span>
    <span class="k">assert</span> <span class="n">mystring9</span> <span class="o">==</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;bbbbbbb&#39;
&#39;bbbbbbb&#39;
</pre></div>
</div>
</div>
</div>
</section>
<section id="exercise-6-filtered-earley-parser">
<h3>Exercise 6: Filtered Earley Parser<a class="headerlink" href="#exercise-6-filtered-earley-parser" title="Link to this heading">#</a></h3>
<p>One of the problems with our Earley and Leo Parsers is that it can get stuck in infinite loops when parsing with grammars that contain token repetitions in alternatives. For example, consider the grammar below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">RECURSION_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;&lt;start&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;A&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;A&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;A&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;A&gt;aa&quot;</span><span class="p">,</span> <span class="s2">&quot;AA&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;B&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;B&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;C&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;C&gt;cc&quot;</span><span class="p">,</span> <span class="s2">&quot;CC&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;C&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;B&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;B&gt;bb&quot;</span><span class="p">,</span> <span class="s2">&quot;BB&quot;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>With this grammar, one can produce an infinite chain of derivations of <code class="docutils literal notranslate"><span class="pre">&lt;A&gt;</span></code>, (direct recursion) or an infinite chain of derivations of <code class="docutils literal notranslate"><span class="pre">&lt;B&gt;</span> <span class="pre">-&gt;</span> <span class="pre">&lt;C&gt;</span> <span class="pre">-&gt;</span> <span class="pre">&lt;B&gt;</span> <span class="pre">...</span></code> (indirect recursion). The problem is that, our implementation can get stuck trying to derive one of these infinite chains. One possibility is to use the <code class="docutils literal notranslate"><span class="pre">LazyExtractor</span></code>. Another, is to simply avoid generating such chains.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ExpectError</span> <span class="kn">import</span> <span class="n">ExpectTimeout</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">ExpectTimeout</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">print_traceback</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">mystring</span> <span class="o">=</span> <span class="s1">&#39;AA&#39;</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">LeoParser</span><span class="p">(</span><span class="n">RECURSION_GRAMMAR</span><span class="p">)</span>
    <span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="n">mystring</span>
    <span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>RecursionError: maximum recursion depth exceeded (expected)
</pre></div>
</div>
</div>
</div>
<p>Can you implement a solution such that any tree that contains such a chain is discarded?</p>
<p><strong>Solution.</strong> Here is a possible solution.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">FilteredLeoParser</span><span class="p">(</span><span class="n">LeoParser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">forest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">seen</span><span class="p">,</span> <span class="n">chart</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_forest</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">seen</span><span class="p">)</span> <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span> <span class="k">else</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">[])</span>

    <span class="k">def</span> <span class="nf">parse_forest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">seen</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">TState</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expand_tstate</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">back</span><span class="p">(),</span> <span class="n">state</span><span class="o">.</span><span class="n">e_col</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">was_seen</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">chain</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># things get reset if we have a non loop</span>
            <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">seen</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># initialization</span>
            <span class="n">seen</span> <span class="o">=</span> <span class="p">{</span><span class="n">state</span><span class="p">}</span>

        <span class="n">pathexprs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_paths</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">s_col</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                                     <span class="n">state</span><span class="o">.</span><span class="n">e_col</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">expr</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">state</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="p">[[(</span><span class="n">s</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">seen</span> <span class="o">|</span> <span class="p">{</span><span class="n">s</span><span class="p">},</span> <span class="n">chart</span><span class="p">)</span>
                             <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">pathexpr</span><span class="p">)</span>
                             <span class="k">if</span> <span class="ow">not</span> <span class="n">was_seen</span><span class="p">(</span><span class="n">seen</span><span class="p">,</span> <span class="n">s</span><span class="p">)]</span> <span class="k">for</span> <span class="n">pathexpr</span> <span class="ow">in</span> <span class="n">pathexprs</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>With the <code class="docutils literal notranslate"><span class="pre">FilteredLeoParser</span></code>, we should be able to recover minimal parse trees in reasonable time.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s1">&#39;AA&#39;</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">FilteredLeoParser</span><span class="p">(</span><span class="n">RECURSION_GRAMMAR</span><span class="p">)</span>
<span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="n">mystring</span>
<span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/3d9105819edc28aaade24986f50e717ac269a675d2959586c093ec95bd3f0bcb.svg" src="_images/3d9105819edc28aaade24986f50e717ac269a675d2959586c093ec95bd3f0bcb.svg" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s1">&#39;AAaa&#39;</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">FilteredLeoParser</span><span class="p">(</span><span class="n">RECURSION_GRAMMAR</span><span class="p">)</span>
<span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="n">mystring</span>
<span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ec25803717ab0d134fc93e2658cb3cd893d17cb003bbf5c0ece9188707e49fed.svg" src="_images/ec25803717ab0d134fc93e2658cb3cd893d17cb003bbf5c0ece9188707e49fed.svg" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s1">&#39;AAaaaa&#39;</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">FilteredLeoParser</span><span class="p">(</span><span class="n">RECURSION_GRAMMAR</span><span class="p">)</span>
<span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="n">mystring</span>
<span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/7733fae988bcd6f8c041bb7480946f6b83aba7eaf36627f2d08221b092f1cf00.svg" src="_images/7733fae988bcd6f8c041bb7480946f6b83aba7eaf36627f2d08221b092f1cf00.svg" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s1">&#39;CC&#39;</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">FilteredLeoParser</span><span class="p">(</span><span class="n">RECURSION_GRAMMAR</span><span class="p">)</span>
<span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="n">mystring</span>
<span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/262dd1438f08097c8d439c90aa641ddabc22686ffa188527e0d4c55033f4514a.svg" src="_images/262dd1438f08097c8d439c90aa641ddabc22686ffa188527e0d4c55033f4514a.svg" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s1">&#39;BBcc&#39;</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">FilteredLeoParser</span><span class="p">(</span><span class="n">RECURSION_GRAMMAR</span><span class="p">)</span>
<span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="n">mystring</span>
<span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/d3ea48ae0ef3235c050647796c83c9f56e6d935ea076fa7e18a47ee0aa380dbd.svg" src="_images/d3ea48ae0ef3235c050647796c83c9f56e6d935ea076fa7e18a47ee0aa380dbd.svg" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s1">&#39;BB&#39;</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">FilteredLeoParser</span><span class="p">(</span><span class="n">RECURSION_GRAMMAR</span><span class="p">)</span>
<span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="n">mystring</span>
<span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/c9836f482f9d3f60ea6d1eaf7c23701e75d06d100bb243436f64b576f4ae577f.svg" src="_images/c9836f482f9d3f60ea6d1eaf7c23701e75d06d100bb243436f64b576f4ae577f.svg" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mystring</span> <span class="o">=</span> <span class="s1">&#39;BBccbb&#39;</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">FilteredLeoParser</span><span class="p">(</span><span class="n">RECURSION_GRAMMAR</span><span class="p">)</span>
<span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">mystring</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="n">mystring</span>
<span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/23e67aa09b139523d106c1c4004c5b64d99dc908e9407f9ce10193ab910146af.svg" src="_images/23e67aa09b139523d106c1c4004c5b64d99dc908e9407f9ce10193ab910146af.svg" />
</div>
</div>
<p>As can be seen, we are able to recover minimal parse trees without hitting on infinite chains.</p>
</section>
<section id="exercise-7-iterative-earley-parser">
<h3>Exercise 7: Iterative Earley Parser<a class="headerlink" href="#exercise-7-iterative-earley-parser" title="Link to this heading">#</a></h3>
<p>Recursive algorithms are quite handy in some cases, but sometimes we might want to have iteration instead of recursion due to memory or speed problems.</p>
<p>Can you implement an iterative version of the <code class="docutils literal notranslate"><span class="pre">EarleyParser</span></code>?</p>
<p><strong>Hint:</strong> In general, you can use a stack to replace a recursive algorithm with an iterative one. An easy way to do this is pushing the parameters onto a stack instead of passing them to the recursive function.</p>
<p><strong>Solution.</strong> Here is a possible solution.</p>
<p>First, we define <code class="docutils literal notranslate"><span class="pre">parse_paths()</span></code> that extract paths from a parsed expression, which is very similar to the original.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">IterativeEarleyParser</span><span class="p">(</span><span class="n">EarleyParser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">parse_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">named_expr_</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">frm</span><span class="p">,</span> <span class="n">til_</span><span class="p">):</span>
        <span class="n">return_paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">path_build_stack</span> <span class="o">=</span> <span class="p">[(</span><span class="n">named_expr_</span><span class="p">,</span> <span class="n">til_</span><span class="p">,</span> <span class="p">[])]</span>

        <span class="k">def</span> <span class="nf">iter_paths</span><span class="p">(</span><span class="n">path_prefix</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">path_prefix</span> <span class="o">+</span> <span class="p">[(</span><span class="n">path</span><span class="p">,</span> <span class="n">k</span><span class="p">)]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">return_paths</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">x</span><span class="p">]</span> <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">frm</span> <span class="k">else</span> <span class="p">[])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">path_build_stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>

        <span class="k">while</span> <span class="n">path_build_stack</span><span class="p">:</span>
            <span class="n">named_expr</span><span class="p">,</span> <span class="n">til</span><span class="p">,</span> <span class="n">path_prefix</span> <span class="o">=</span> <span class="n">path_build_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="o">*</span><span class="n">expr</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="n">named_expr</span>

            <span class="n">starts</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cgrammar</span><span class="p">:</span>
                <span class="n">starts</span> <span class="o">=</span> <span class="p">([(</span><span class="n">var</span><span class="p">,</span> <span class="n">til</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="p">),</span> <span class="s1">&#39;t&#39;</span><span class="p">)]</span>
                          <span class="k">if</span> <span class="n">til</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">chart</span><span class="p">[</span><span class="n">til</span><span class="p">]</span><span class="o">.</span><span class="n">letter</span> <span class="o">==</span> <span class="n">var</span> <span class="k">else</span> <span class="p">[])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">starts</span> <span class="o">=</span> <span class="p">[(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">s_col</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">chart</span><span class="p">[</span><span class="n">til</span><span class="p">]</span><span class="o">.</span><span class="n">states</span>
                          <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">finished</span><span class="p">()</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">var</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">starts</span><span class="p">:</span>
                <span class="n">iter_paths</span><span class="p">(</span><span class="n">path_prefix</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">return_paths</span>
</pre></div>
</div>
</div>
</div>
<p>Next we used these paths to recover the forest data structure using <code class="docutils literal notranslate"><span class="pre">parse_forest()</span></code>. Since <code class="docutils literal notranslate"><span class="pre">parse_forest()</span></code> does not recurse, we reuse the original definition. Next, we define <code class="docutils literal notranslate"><span class="pre">extract_a_tree()</span></code></p>
<p>Now we are ready to extract trees from the forest using <code class="docutils literal notranslate"><span class="pre">extract_a_tree()</span></code></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">IterativeEarleyParser</span><span class="p">(</span><span class="n">IterativeEarleyParser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">choose_a_node_to_explore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_paths</span><span class="p">,</span> <span class="n">level_count</span><span class="p">):</span>
        <span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">node_paths</span>
        <span class="k">return</span> <span class="n">first</span>

    <span class="k">def</span> <span class="nf">extract_a_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forest_node_</span><span class="p">):</span>
        <span class="n">start_node</span> <span class="o">=</span> <span class="p">(</span><span class="n">forest_node_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[])</span>
        <span class="n">tree_build_stack</span> <span class="o">=</span> <span class="p">[(</span><span class="n">forest_node_</span><span class="p">,</span> <span class="n">start_node</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)]</span>

        <span class="k">while</span> <span class="n">tree_build_stack</span><span class="p">:</span>
            <span class="n">forest_node</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">level_count</span> <span class="o">=</span> <span class="n">tree_build_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">paths</span> <span class="o">=</span> <span class="n">forest_node</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">paths</span><span class="p">:</span>
                <span class="n">tree</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="p">[]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_tree</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">current_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">choose_a_node_to_explore</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">level_count</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">current_node</span><span class="p">):</span>
                    <span class="n">new_forest_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forest</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
                    <span class="n">tree_build_stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">new_forest_node</span><span class="p">,</span> <span class="n">new_tree</span><span class="p">,</span> <span class="n">level_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">tree</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">new_tree</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">start_node</span>
</pre></div>
</div>
</div>
</div>
<p>For now, we simply extract the first tree found.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">IterativeEarleyParser</span><span class="p">(</span><span class="n">IterativeEarleyParser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">extract_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forest</span><span class="p">):</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_a_tree</span><span class="p">(</span><span class="n">forest</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s see if it works with some of the grammars we have seen so far.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">test_cases</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Grammar</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="n">A1_GRAMMAR</span><span class="p">,</span> <span class="s1">&#39;1-2-3+4-5&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="n">A2_GRAMMAR</span><span class="p">,</span> <span class="s1">&#39;1+2&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="n">A3_GRAMMAR</span><span class="p">,</span> <span class="s1">&#39;1+2+3-6=6-1-2-3&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="n">LR_GRAMMAR</span><span class="p">,</span> <span class="s1">&#39;aaaaa&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="n">RR_GRAMMAR</span><span class="p">,</span> <span class="s1">&#39;aa&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="n">DIRECTLY_SELF_REFERRING</span><span class="p">,</span> <span class="s1">&#39;select a from a&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="n">INDIRECTLY_SELF_REFERRING</span><span class="p">,</span> <span class="s1">&#39;select a from a&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="n">RECURSION_GRAMMAR</span><span class="p">,</span> <span class="s1">&#39;AA&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="n">RECURSION_GRAMMAR</span><span class="p">,</span> <span class="s1">&#39;AAaaaa&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="n">RECURSION_GRAMMAR</span><span class="p">,</span> <span class="s1">&#39;BBccbb&#39;</span><span class="p">)</span>
<span class="p">]</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">test_cases</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
    <span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">IterativeEarleyParser</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">text</span> <span class="o">==</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0 1-2-3+4-5
1 1+2
2 1+2+3-6=6-1-2-3
3 aaaaa
4 aa
5 select a from a
6 select a from a
7 AA
8 AAaaaa
9 BBccbb
</pre></div>
</div>
</div>
</div>
<p>As can be seen, our <code class="docutils literal notranslate"><span class="pre">IterativeEarleyParser</span></code> is able to handle recursive grammars. However, it can only extract the first tree found. What should one do to get all possible parses? What we can do, is to keep track of options to explore at each <code class="docutils literal notranslate"><span class="pre">choose_a_node_to_explore()</span></code>. Next, capture in the nodes explored in a tree data structure, adding new paths each time a new leaf is expanded. See the <code class="docutils literal notranslate"><span class="pre">TraceTree</span></code> datastructure in the <a class="reference internal" href="ConcolicFuzzer.html"><span class="std std-doc">chapter on Concolic fuzzing</span></a> for an example.</p>
</section>
<section id="exercise-8-first-set-of-a-nonterminal">
<h3>Exercise 8: First Set of a Nonterminal<a class="headerlink" href="#exercise-8-first-set-of-a-nonterminal" title="Link to this heading">#</a></h3>
<p>We previously gave a way to extract the <code class="docutils literal notranslate"><span class="pre">nullable</span></code> (epsilon) set, which is often used for parsing.
Along with <code class="docutils literal notranslate"><span class="pre">nullable</span></code>, parsing algorithms often use two other sets <a class="reference external" href="https://en.wikipedia.org/wiki/Canonical_LR_parser#FIRST_and_FOLLOW_sets"><code class="docutils literal notranslate"><span class="pre">first</span></code> and <code class="docutils literal notranslate"><span class="pre">follow</span></code></a>.
The first set of a terminal symbol is itself, and the first set of a nonterminal is composed of terminal symbols that can come at the beginning of any derivation
of that nonterminal. The first set of any nonterminal that can derive the empty string should contain <code class="docutils literal notranslate"><span class="pre">EPSILON</span></code>. For example, using our <code class="docutils literal notranslate"><span class="pre">A1_GRAMMAR</span></code>, the first set of both <code class="docutils literal notranslate"><span class="pre">&lt;expr&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;start&gt;</span></code> is <code class="docutils literal notranslate"><span class="pre">{0,1,2,3,4,5,6,7,8,9}</span></code>. The extraction first set for any self-recursive nonterminal is simple enough. One simply has to recursively compute the first set of the first element of its choice expressions. The computation of <code class="docutils literal notranslate"><span class="pre">first</span></code> set for a self-recursive nonterminal is tricky. One has to recursively compute the first set until one is sure that no more terminals can be added to the first set.</p>
<p>Can you implement the <code class="docutils literal notranslate"><span class="pre">first</span></code> set using our <code class="docutils literal notranslate"><span class="pre">fixpoint()</span></code> decorator?</p>
<p><strong>Solution.</strong> The first set of all terminals is the set containing just themselves. So we initialize that first. Then we update the first set with rules that derive empty strings.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">firstset</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">nullable</span><span class="p">):</span>
    <span class="n">first</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="p">{</span><span class="n">i</span><span class="p">}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">terminals</span><span class="p">(</span><span class="n">grammar</span><span class="p">)}</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">grammar</span><span class="p">:</span>
        <span class="n">first</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">EPSILON</span><span class="p">}</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nullable</span> <span class="k">else</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">firstset_</span><span class="p">((</span><span class="n">rules</span><span class="p">(</span><span class="n">grammar</span><span class="p">),</span> <span class="n">first</span><span class="p">,</span> <span class="n">nullable</span><span class="p">))[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Finally, we rely on the <code class="docutils literal notranslate"><span class="pre">fixpoint</span></code> to update the first set with the contents of the current first set until the first set stops changing.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">first_expr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">nullable</span><span class="p">):</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">expr</span><span class="p">:</span>
        <span class="n">tokens</span> <span class="o">|=</span> <span class="n">first</span><span class="p">[</span><span class="n">token</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">token</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nullable</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">tokens</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@fixpoint</span>
<span class="k">def</span> <span class="nf">firstset_</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="p">(</span><span class="n">rules</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span> <span class="o">=</span> <span class="n">arg</span>
    <span class="k">for</span> <span class="n">A</span><span class="p">,</span> <span class="n">expression</span> <span class="ow">in</span> <span class="n">rules</span><span class="p">:</span>
        <span class="n">first</span><span class="p">[</span><span class="n">A</span><span class="p">]</span> <span class="o">|=</span> <span class="n">first_expr</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">rules</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">firstset</span><span class="p">(</span><span class="n">canonical</span><span class="p">(</span><span class="n">A1_GRAMMAR</span><span class="p">),</span> <span class="n">EPSILON</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;1&#39;: {&#39;1&#39;},
 &#39;4&#39;: {&#39;4&#39;},
 &#39;0&#39;: {&#39;0&#39;},
 &#39;6&#39;: {&#39;6&#39;},
 &#39;2&#39;: {&#39;2&#39;},
 &#39;8&#39;: {&#39;8&#39;},
 &#39;7&#39;: {&#39;7&#39;},
 &#39;9&#39;: {&#39;9&#39;},
 &#39;5&#39;: {&#39;5&#39;},
 &#39;3&#39;: {&#39;3&#39;},
 &#39;-&#39;: {&#39;-&#39;},
 &#39;+&#39;: {&#39;+&#39;},
 &#39;&lt;start&gt;&#39;: {&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;},
 &#39;&lt;expr&gt;&#39;: {&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;},
 &#39;&lt;integer&gt;&#39;: {&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;},
 &#39;&lt;digit&gt;&#39;: {&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;}}
</pre></div>
</div>
</div>
</div>
</section>
<section id="exercise-9-follow-set-of-a-nonterminal">
<h3>Exercise 9: Follow Set of a Nonterminal<a class="headerlink" href="#exercise-9-follow-set-of-a-nonterminal" title="Link to this heading">#</a></h3>
<p>The follow set definition is similar to the first set. The follow set of a nonterminal is the set of terminals that can occur just after that nonterminal is used in any derivation. The follow set of the start symbol is <code class="docutils literal notranslate"><span class="pre">EOF</span></code>, and the follow set of any nonterminal is the super set of first sets of all symbols that come after it in any choice expression.</p>
<p>For example, the follow set of <code class="docutils literal notranslate"><span class="pre">&lt;expr&gt;</span></code> in <code class="docutils literal notranslate"><span class="pre">A1_GRAMMAR</span></code> is the set <code class="docutils literal notranslate"><span class="pre">{EOF,</span> <span class="pre">+,</span> <span class="pre">-}</span></code>.</p>
<p>As in the previous exercise, implement the <code class="docutils literal notranslate"><span class="pre">followset()</span></code> using the <code class="docutils literal notranslate"><span class="pre">fixpoint()</span></code> decorator.</p>
<p><strong>Solution.</strong> The implementation of <code class="docutils literal notranslate"><span class="pre">followset()</span></code> is similar to <code class="docutils literal notranslate"><span class="pre">firstset()</span></code>. We first initialize the follow set with <code class="docutils literal notranslate"><span class="pre">EOF</span></code>, get the epsilon and first sets, and use the <code class="docutils literal notranslate"><span class="pre">fixpoint()</span></code> decorator to iteratively compute the follow set until nothing changes.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">EOF</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">followset</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
    <span class="n">follow</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">grammar</span><span class="p">}</span>
    <span class="n">follow</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">EOF</span><span class="p">}</span>

    <span class="n">epsilon</span> <span class="o">=</span> <span class="n">nullable</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span>
    <span class="n">first</span> <span class="o">=</span> <span class="n">firstset</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">followset_</span><span class="p">((</span><span class="n">grammar</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">follow</span><span class="p">))[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Given the current follow set, one can update the follow set as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@fixpoint</span>
<span class="k">def</span> <span class="nf">followset_</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="n">grammar</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">follow</span> <span class="o">=</span> <span class="n">arg</span>
    <span class="k">for</span> <span class="n">A</span><span class="p">,</span> <span class="n">expression</span> <span class="ow">in</span> <span class="n">rules</span><span class="p">(</span><span class="n">grammar</span><span class="p">):</span>
        <span class="n">f_B</span> <span class="o">=</span> <span class="n">follow</span><span class="p">[</span><span class="n">A</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">expression</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">grammar</span><span class="p">:</span>
                <span class="n">follow</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">|=</span> <span class="n">f_B</span>
            <span class="n">f_B</span> <span class="o">=</span> <span class="n">f_B</span> <span class="o">|</span> <span class="n">first</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">epsilon</span> <span class="k">else</span> <span class="p">(</span><span class="n">first</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="p">{</span><span class="n">EPSILON</span><span class="p">})</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">follow</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">followset</span><span class="p">(</span><span class="n">canonical</span><span class="p">(</span><span class="n">A1_GRAMMAR</span><span class="p">),</span> <span class="n">START_SYMBOL</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;&lt;start&gt;&#39;: {&#39;\x00&#39;},
 &#39;&lt;expr&gt;&#39;: {&#39;\x00&#39;, &#39;+&#39;, &#39;-&#39;},
 &#39;&lt;integer&gt;&#39;: {&#39;\x00&#39;, &#39;+&#39;, &#39;-&#39;},
 &#39;&lt;digit&gt;&#39;: {&#39;\x00&#39;,
  &#39;+&#39;,
  &#39;-&#39;,
  &#39;0&#39;,
  &#39;1&#39;,
  &#39;2&#39;,
  &#39;3&#39;,
  &#39;4&#39;,
  &#39;5&#39;,
  &#39;6&#39;,
  &#39;7&#39;,
  &#39;8&#39;,
  &#39;9&#39;}}
</pre></div>
</div>
</div>
</div>
</section>
<section id="exercise-10-a-ll-1-parser">
<h3>Exercise 10: A LL(1) Parser<a class="headerlink" href="#exercise-10-a-ll-1-parser" title="Link to this heading">#</a></h3>
<p>As we mentioned previously, there exist other kinds of parsers that operate left-to-right with right most derivation (<em>LR(k)</em>) or left-to-right with left most derivation (<em>LL(k)</em>) with <em>k</em> signifying the amount of lookahead the parser is permitted to use.</p>
<p>What should one do with the lookahead? That lookahead can be used to determine which rule to apply. In the case of an <em>LL(1)</em> parser, the rule to apply is determined by looking at the <em>first</em> set of the different rules. We previously implemented <code class="docutils literal notranslate"><span class="pre">first_expr()</span></code> that takes an expression, the set of  <code class="docutils literal notranslate"><span class="pre">nullables</span></code>, and computes the first set of that rule.</p>
<p>If a rule can derive an empty set, then that rule may also be applicable if of sees the <code class="docutils literal notranslate"><span class="pre">follow()</span></code> set of the corresponding nonterminal.</p>
<section id="part-1-a-ll-1-parsing-table">
<h4>Part 1: A LL(1) Parsing Table<a class="headerlink" href="#part-1-a-ll-1-parsing-table" title="Link to this heading">#</a></h4>
<p>The first part of this exercise is to implement the <em>parse table</em> that describes what action to take for an <em>LL(1)</em> parser on seeing a terminal symbol on lookahead.  The table should be in the form of a <em>dictionary</em> such that the keys represent the nonterminal symbol, and the value should contain another dictionary with keys as terminal symbols and the particular rule to continue parsing as the value.</p>
<p>Let us illustrate this table with an example.  The <code class="docutils literal notranslate"><span class="pre">parse_table()</span></code> method populates a <code class="docutils literal notranslate"><span class="pre">self.table</span></code> data structure that should conform to the following requirements:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LL1Parser</span><span class="p">(</span><span class="n">Parser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">parse_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">my_rules</span> <span class="o">=</span> <span class="n">rules</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cgrammar</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">table</span> <span class="o">=</span> <span class="o">...</span>          <span class="c1"># fill in here to produce</span>

    <span class="k">def</span> <span class="nf">rules</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">rule</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">my_rules</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">rule</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">show_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">terminals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cgrammar</span><span class="p">)))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Rule Name</span><span class="se">\t</span><span class="s1">| </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="s1">&#39; | &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ts</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">:</span>
            <span class="n">pr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">actions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">pr</span><span class="p">[</span><span class="n">t</span><span class="p">])</span> <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">pr</span> <span class="k">else</span> <span class="s1">&#39; &#39;</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ts</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">  </span><span class="se">\t</span><span class="s1">| </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s1">&#39; | &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">actions</span><span class="p">)))</span>
</pre></div>
</div>
</div>
</div>
<p>On invocation of <code class="docutils literal notranslate"><span class="pre">LL1Parser(A2_GRAMMAR).show_table()</span></code>
It should result in the following table:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rules</span><span class="p">(</span><span class="n">canonical</span><span class="p">(</span><span class="n">A2_GRAMMAR</span><span class="p">))):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="se">\t</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> := </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0	 &lt;start&gt; := [&#39;&lt;expr&gt;&#39;]
1	 &lt;expr&gt; := [&#39;&lt;integer&gt;&#39;, &#39;&lt;expr_&gt;&#39;]
2	 &lt;expr_&gt; := [&#39;+&#39;, &#39;&lt;expr&gt;&#39;]
3	 &lt;expr_&gt; := [&#39;-&#39;, &#39;&lt;expr&gt;&#39;]
4	 &lt;expr_&gt; := []
5	 &lt;integer&gt; := [&#39;&lt;digit&gt;&#39;, &#39;&lt;integer_&gt;&#39;]
6	 &lt;integer_&gt; := [&#39;&lt;integer&gt;&#39;]
7	 &lt;integer_&gt; := []
8	 &lt;digit&gt; := [&#39;0&#39;]
9	 &lt;digit&gt; := [&#39;1&#39;]
10	 &lt;digit&gt; := [&#39;2&#39;]
11	 &lt;digit&gt; := [&#39;3&#39;]
12	 &lt;digit&gt; := [&#39;4&#39;]
13	 &lt;digit&gt; := [&#39;5&#39;]
14	 &lt;digit&gt; := [&#39;6&#39;]
15	 &lt;digit&gt; := [&#39;7&#39;]
16	 &lt;digit&gt; := [&#39;8&#39;]
17	 &lt;digit&gt; := [&#39;9&#39;]
</pre></div>
</div>
</div>
</div>
<p>|Rule Name  || + | - | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9|
|———–||—|—|—|—|—|—|—|—|—|—|—|–|
|start  	||   |   | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0|
|expr   	||   |   | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1|
|expr_  	|| 2 | 3 |   |   |   |   |   |   |   |   |   |  |
|integer  	||   |   | 5 | 5 | 5 | 5 | 5 | 5 | 5 | 5 | 5 | 5|
|integer_  	|| 7 | 7 | 6 | 6 | 6 | 6 | 6 | 6 | 6 | 6 | 6 | 6|
|digit  	||   |   | 8 | 9 |10 |11 |12 |13 |14 |15 |16 |17|</p>
<p><strong>Solution.</strong> We define <code class="docutils literal notranslate"><span class="pre">predict()</span></code> as we explained before. Then we use the predicted rules to populate the parse table.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LL1Parser</span><span class="p">(</span><span class="n">LL1Parser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rulepair</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">follow</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">):</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">rule</span> <span class="o">=</span> <span class="n">rulepair</span>
        <span class="n">rf</span> <span class="o">=</span> <span class="n">first_expr</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nullable_expr</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">):</span>
            <span class="n">rf</span> <span class="o">|=</span> <span class="n">follow</span><span class="p">[</span><span class="n">A</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">rf</span>

    <span class="k">def</span> <span class="nf">parse_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">my_rules</span> <span class="o">=</span> <span class="n">rules</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cgrammar</span><span class="p">)</span>
        <span class="n">epsilon</span> <span class="o">=</span> <span class="n">nullable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cgrammar</span><span class="p">)</span>
        <span class="n">first</span> <span class="o">=</span> <span class="n">firstset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cgrammar</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>
        <span class="c1"># inefficient, can combine the three.</span>
        <span class="n">follow</span> <span class="o">=</span> <span class="n">followset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cgrammar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_symbol</span><span class="p">())</span>

        <span class="n">ptable</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">follow</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">))</span>
                  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">rule</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">my_rules</span><span class="p">)]</span>

        <span class="n">parse_tbl</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="p">{}</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cgrammar</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pvals</span> <span class="ow">in</span> <span class="n">ptable</span><span class="p">:</span>
            <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">my_rules</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">parse_tbl</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">v</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">pvals</span><span class="p">})</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">table</span> <span class="o">=</span> <span class="n">parse_tbl</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ll1parser</span> <span class="o">=</span> <span class="n">LL1Parser</span><span class="p">(</span><span class="n">A2_GRAMMAR</span><span class="p">)</span>
<span class="n">ll1parser</span><span class="o">.</span><span class="n">parse_table</span><span class="p">()</span>
<span class="n">ll1parser</span><span class="o">.</span><span class="n">show_table</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Rule Name	| + | - | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
&lt;start&gt;  	|   |   | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0
&lt;expr&gt;  	|   |   | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1
&lt;expr_&gt;  	| 2 | 3 |   |   |   |   |   |   |   |   |   |  
&lt;integer&gt;  	|   |   | 5 | 5 | 5 | 5 | 5 | 5 | 5 | 5 | 5 | 5
&lt;integer_&gt;  	| 7 | 7 | 6 | 6 | 6 | 6 | 6 | 6 | 6 | 6 | 6 | 6
&lt;digit&gt;  	|   |   | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17
</pre></div>
</div>
</div>
</div>
</section>
<section id="part-2-the-parser">
<h4>Part 2: The Parser<a class="headerlink" href="#part-2-the-parser" title="Link to this heading">#</a></h4>
<p>Once we have the parse table, implementing the parser is as follows: Consider the first item from the sequence of tokens to parse, and seed the stack with the start symbol.</p>
<p>While the stack is not empty, extract the first symbol from the stack, and if the symbol is a terminal, verify that the symbol matches the item from the input stream. If the symbol is a nonterminal, use the symbol and input item to look up the next rule from the parse table. Insert the rule thus found to the top of the stack. Keep track of the expressions being parsed to build up the parse table.</p>
<p>Use the parse table defined previously to implement the complete LL(1) parser.</p>
<p><strong>Solution.</strong> Here is the complete parser:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LL1Parser</span><span class="p">(</span><span class="n">LL1Parser</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">parse_helper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="n">inplst</span><span class="p">):</span>
        <span class="n">inp</span><span class="p">,</span> <span class="o">*</span><span class="n">inplst</span> <span class="o">=</span> <span class="n">inplst</span>
        <span class="n">exprs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">val</span><span class="p">,</span> <span class="o">*</span><span class="n">stack</span> <span class="o">=</span> <span class="n">stack</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">val</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cgrammar</span><span class="p">:</span>  <span class="c1"># terminal</span>
                <span class="k">assert</span> <span class="n">val</span> <span class="o">==</span> <span class="n">inp</span>
                <span class="n">exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="n">inp</span><span class="p">,</span> <span class="o">*</span><span class="n">inplst</span> <span class="o">=</span> <span class="n">inplst</span> <span class="ow">or</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">inp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">[</span><span class="n">val</span><span class="p">][</span><span class="n">inp</span><span class="p">]</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">rhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">my_rules</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">stack</span> <span class="o">=</span> <span class="n">rhs</span> <span class="o">+</span> <span class="p">[(</span><span class="n">val</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhs</span><span class="p">))]</span> <span class="o">+</span> <span class="n">stack</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_to_tree</span><span class="p">(</span><span class="n">exprs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parse_table</span><span class="p">()</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">my_rules</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_helper</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">inp</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">linear_to_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">arr</span><span class="p">:</span>
            <span class="n">elt</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elt</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">elt</span><span class="p">,</span> <span class="p">[]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># get the last n</span>
                <span class="n">sym</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">elt</span>
                <span class="n">elts</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="p">:]</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">[]</span>
                <span class="n">stack</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span><span class="p">]</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">sym</span><span class="p">,</span> <span class="n">elts</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ll1parser</span> <span class="o">=</span> <span class="n">LL1Parser</span><span class="p">(</span><span class="n">A2_GRAMMAR</span><span class="p">)</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">ll1parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;1+2&#39;</span><span class="p">)</span>
<span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/c321c01a5bd85add393980d22e39e991d35ed736ec0082c50acb184773a868ec.svg" src="_images/c321c01a5bd85add393980d22e39e991d35ed736ec0082c50acb184773a868ec.svg" />
</div>
</div>
</section>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="GrammarCoverageFuzzer.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Grammar Coverage</p>
      </div>
    </a>
    <a class="right-next"
       href="ProbabilisticGrammarFuzzer.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Probabilistic Grammar Fuzzing</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#synopsis">Synopsis</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#why-parsing-for-fuzzing">Why Parsing for Fuzzing?</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#using-a-parser">Using a Parser</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#an-ad-hoc-parser">An Ad Hoc Parser</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#grammars-in-parsing">Grammars in Parsing</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-grammars-and-derivation-trees">Excursion: Grammars and Derivation Trees</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#end-of-excursion">End of Excursion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-recursion">Excursion: Recursion</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#recursion">Recursion</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#ambiguity">Ambiguity</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">End of Excursion</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-parser-class">A Parser Class</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-canonical-grammars">Excursion: Canonical Grammars</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">End of Excursion</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#parsing-expression-grammars">Parsing Expression Grammars</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-packrat-parser-for-predicate-expression-grammars">The Packrat Parser for Predicate Expression Grammars</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-implementing-pegparser">Excursion: Implementing <code class="docutils literal notranslate"><span class="pre">PEGParser</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#unify-key">Unify Key</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#unify-rule">Unify Rule</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">End of Excursion</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#parsing-context-free-grammars">Parsing Context-Free Grammars</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problems-with-peg">Problems with PEG</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-earley-parser">The Earley Parser</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-implementing-earleyparser">Excursion: Implementing <code class="docutils literal notranslate"><span class="pre">EarleyParser</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#columns">Columns</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#items">Items</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#states">States</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#the-parsing-algorithm">The Parsing Algorithm</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#predicting-states">Predicting States</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#scanning-tokens">Scanning Tokens</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#completing-processing">Completing Processing</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#filling-the-chart">Filling the Chart</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#the-parse-method">The Parse Method</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#parsing-paths">Parsing Paths</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#parsing-forests">Parsing Forests</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#extracting-trees">Extracting Trees</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#ambiguous-parsing">Ambiguous Parsing</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#the-aycock-epsilon-fix">The Aycock Epsilon Fix</a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#fixpoint">Fixpoint</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#nullable">Nullable</a></li>
</ul>
</li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#tree-extractor">Tree Extractor</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#more-earley-parsing">More Earley Parsing</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">End of Excursion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-testing-the-parsers">Excursion: Testing the Parsers</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">End of Excursion</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#background">Background</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">Synopsis</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#lessons-learned">Lessons Learned</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#next-steps">Next Steps</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">Exercises</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-1-an-alternative-packrat">Exercise 1: An Alternative Packrat</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-2-more-peg-syntax">Exercise 2: More PEG Syntax</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-3-peg-predicates">Exercise 3: PEG Predicates</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-4-earley-fill-chart">Exercise 4: Earley Fill Chart</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-5-leo-parser">Exercise 5: Leo Parser</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-6-filtered-earley-parser">Exercise 6: Filtered Earley Parser</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-7-iterative-earley-parser">Exercise 7: Iterative Earley Parser</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-8-first-set-of-a-nonterminal">Exercise 8: First Set of a Nonterminal</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-9-follow-set-of-a-nonterminal">Exercise 9: Follow Set of a Nonterminal</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-10-a-ll-1-parser">Exercise 10: A LL(1) Parser</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#part-1-a-ll-1-parsing-table">Part 1: A LL(1) Parsing Table</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#part-2-the-parser">Part 2: The Parser</a></li>
</ul>
</li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian Holler
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2021-2025 CISPA Helmholtz Center for Information Security (www.cispa.de); © Copyright 2018-2020 Saarland University, authors, and contributors. All Rights Reserved.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>