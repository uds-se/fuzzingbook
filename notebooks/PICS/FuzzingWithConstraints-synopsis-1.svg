<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 5.0.0 (20220707.1540)
 -->
<!-- Pages: 1 -->
<svg width="228pt" height="62pt"
 viewBox="0.00 0.00 228.00 62.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 58)">
<g id="a_graph0"><a xlink:title="ISLaSolver class hierarchy">
<polygon fill="white" stroke="transparent" points="-4,4 -4,-58 224,-58 224,4 -4,4"/>
</a>
</g>
<!-- ISLaSolver -->
<g id="node1" class="node">
<title>ISLaSolver</title>
<g id="a_node1"><a xlink:href="isla.solver.ipynb" xlink:title="class ISLaSolver">
<polygon fill="none" stroke="black" points="0,-0.5 0,-53.5 82,-53.5 82,-0.5 0,-0.5"/>
<text text-anchor="start" x="8" y="-39.3" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">ISLaSolver</text>
<polyline fill="none" stroke="black" points="0,-30.5 82,-30.5 "/>
<g id="a_node1_0"><a xlink:href="#" xlink:title="ISLaSolver">
<g id="a_node1_1"><a xlink:href="isla.solver.ipynb" xlink:title="__init__(self, grammar: Dict[str, List[str]], formula: Union[isla.language.Formula, str], structural_predicates: Set[isla.language.StructuralPredicate] = {Predicate(nth, 3), Predicate(inside, 2), Predicate(before, 2), Predicate(level, 4), Predicate(after, 2), Predicate(different_position, 2), Predicate(same_position, 2), Predicate(consecutive, 2)}, semantic_predicates: Set[isla.language.SemanticPredicate] = {SemanticPredicate(count, 3)}, max_number_free_instantiations: int = 10, max_number_smt_instantiations: int = 10, max_number_tree_insertion_results: int = 5, enforce_unique_trees_in_queue: bool = True, precompute_reachability: bool = False, debug: bool = False, cost_computer: Optional[ForwardRef(&#39;CostComputer&#39;)] = None, timeout_seconds: Optional[int] = None, global_fuzzer: bool = False, predicates_unique_in_int_arg: Tuple[isla.language.SemanticPredicate, ...] = (SemanticPredicate(count, 3),), fuzzer_factory: Callable[[Dict[str, List[str]]], isla.fuzzer.GrammarFuzzer] = &lt;function ISLaSolver.&lt;lambda&gt; at 0x10cf2e830&gt;, tree_insertion_methods=7):&#10;:param grammar: The underlying grammar.&#10;:param formula: The formula to solve.&#10;:param max_number_free_instantiations: Number of times that nonterminals that are not bound by any formula&#10;should be expanded by a coverage&#45;based fuzzer.&#10;:param max_number_smt_instantiations: Number of solutions of SMT formulas that should be produced.&#10;:param precompute_reachability: If true, the distances between all grammar nodes are pre&#45;computed using&#10;Floyd&#45;Warshall&#39;s algorithm. This makes sense if there are many expensive distance queries, e.g., in a big&#10;grammar and a constraint with relatively many universal quantifiers.&#10;:param debug: If true, debug information about the evolution of states is collected, notably in the&#10;field state_tree. The root of the tree is in the field state_tree_root. The field costs stores the computed&#10;cost values for all new nodes.&#10;:param global_fuzzer: If set to True, only one coverage&#45;guided grammar fuzzer object is used to finish&#10;off unconstrained open derivation trees throughout the whole generation time. This may be beneficial for&#10;some targets; e.g., we experienced that CSV works significantly faster. However, the achieved k&#45;path coverage&#10;can be lower with that setting.&#10;:param predicates_unique_in_int_arg: This is needed in certain cases for instantiating universal&#10;integer quantifiers. The supplied predicates should have exactly one integer argument, and hold&#10;for exactly one integer value once all other parameters are fixed.&#10;:param fuzzer_factory: Constructor of the fuzzer to use for instantiating &quot;free&quot; nonterminals.&#10;:param tree_insertion_methods: Combination of methods to use for existential quantifier elimination by&#10;tree insertion. Full selection: `DIRECT_EMBEDDING &amp; SELF_EMBEDDING &amp; CONTEXT_ADDITION`.">
<text text-anchor="start" x="11" y="-19.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">__init__()</text>
</a>
</g>
<g id="a_node1_2"><a xlink:href="isla.solver.ipynb" xlink:title="solve(self) &#45;&gt; Generator[isla.derivation_tree.DerivationTree, NoneType, NoneType]">
<text text-anchor="start" x="11" y="-8.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">solve()</text>
</a>
</g>
</a>
</g>
</a>
</g>
</g>
<!-- Legend -->
<g id="node2" class="node">
<title>Legend</title>
<text text-anchor="start" x="100" y="-44.5" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="10.00" fill="#b03a2e">Legend</text>
<text text-anchor="start" x="100" y="-34.5" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
<text text-anchor="start" x="107" y="-34.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="8.00">public_method()</text>
<text text-anchor="start" x="100" y="-24.5" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
<text text-anchor="start" x="107" y="-24.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text>
<text text-anchor="start" x="100" y="-14.5" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
<text text-anchor="start" x="107" y="-14.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
<text text-anchor="start" x="100" y="-5.3" font-family="Helvetica,sans-Serif" font-size="9.00">Hover over names to see doc</text>
</g>
</g>
</svg>
